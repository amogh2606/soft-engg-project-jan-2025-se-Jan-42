[Music] welcome back last lecture of week two in the earlier lecture we saw algorithms for structural graph coverage criteria now what i am going to tell you is how to derive the test requirements if you have a graph from a software artifact and if you would like to achieve structural coverage criteria let us say node coverage or covering loops which is prime paths how to actually get the test requirements are there algorithms to do it we learn the fundamentals of these algorithms based on the elementary graph algorithms that we saw and towards the end i will point you to a nice web application that you can use to automate it so as i told you think of a broad goal as i have software artifacts with me procedures code methods and i also can have design elements requirements and i have generated graphs from them and i would like to apply structural coverage criteria on these generated graphs to test the software artifact for execution of every node which corresponds to every statement for execution of every edge might correspond to branching for execution of loops which might correspond to prime paths and so on so now we are going to learn how to get the test paths for these various test requirements and the case of prime paths how to get the test requirements itself so these are all the structural coverage criteria that we saw in the previous lecture node coverage edge coverage covering pairs of edges covering paths complete path coverage which we said is not useful if the graph has loops specified path coverage very specifically prime path coverage for loops and then round trips simple round trip and complete round trip so for each of these coverage criteria we will see how to write the test requirements and how to get test paths that will achieve the test requirements so as i told you per coverage criteria we have two entities one is the test requirement itself which is easy like for node coverage you you already have it as a part of the graph and the other is the test path to achieve the test requirement so how are we going to get these two entities so we're going to see algorithms that will tell you how to find present the test requirements and how to get the test paths for these test requirement assuming that the requirement is feasible right we don't really have procedures to check if the requirement is feasible or unfeasible we won't really see that part we leave it to the tester based on the application to see whether the requirement can be achieved or not if it can be met we say if it's feasible if it cannot be met then we say it is infeasible so node and edge coverage were two simple coverage criteria that we saw there is nothing much in terms of algorithms for writing the test requirements for them they come as part of the graphs themselves test requirement for node coverage is given as the set of nodes along with the graph test requirement for edge coverage is given as the set of edges along with the graph itself so the test paths to achieve node and edge coverage how do i get them we just saw bfs breadth first search remember what did breadth first search do it gives you a systematic procedure to visit every node that is reachable from one of the initial nodes so in graphs for testing we already have marked initial nodes so run breadth first search from that initial node all the nodes that are reachable from that node will give you test paths that achieve node coverage you just have to ensure that the test path ends in a final vertex same thing for edge coverage also there is no big deal in fact breadth first search in addition gives you shortest paths which is a useful property which you may or may not use in the context of testing so it is fairly easy to write test requirements and test paths for both node and edge coverage if you happen to have a node that is unreachable from an initial node then that particular node coverage criteria is becomes infeasible so you leave it at that as long as all the nodes are reachable from the initial node i can always use an algorithm like breadth first search to be able to get test paths for both node coverage and edge coverage the next is edge pair coverage this is we saw right pairs of edges test requirement for edge pair coverage is all parts of length 2 in the given graph so we need to include parts that involve self loops also we saw in that example comparing prime paths to edge pair coverage that self loops come for edge pairs so it's again quite easy to enumerate test requirements for edge pair coverage they could themselves be the test paths as long as they start in an initial node and end in a final node so i have just written the same thing as a simple algorithm so you take nodes in the graph let us say take a node u in the graph for each such node in the u in the graph consider the adjacency list of u let us say there is a node v in the adjacency list of u now you look at a node look at the adjacency list of v and look at the node w in the adjacency list of v and the edge pair coverage test requirement that you want is u to v to w pairs of edges which is parts of length 2. if u and w happen to be initial and final vertices you are done then and there otherwise expand you to the left by augmenting it with a test path that starts in an initial vertex and similarly if w is not a final vertex this adds some extra vertices to the n to get it as a final vertex so that was edge pair coverage specified path coverage some user tester gives you a set of paths if the graph is without loops then specified path coverage can be easily achieved because you can cover all the parts you can do complete path coverage uh for graph and any any algorithm depth first search or breadth first search will let you do for graphs with loops we saw complete path coverage is infeasible specified path coverage is the only feasible test requirement again for the set of paths that i need i can always modify breadth first search algorithm to get specified path coverage the rest of this lecture let's spend it on this most interesting structural coverage criteria which is prime path coverage as the test requirement so what did we see to recap prime paths are maximal simple paths so when i define ah prime paths coverage as my test requirement i need to first get the prime paths from the graph so how do i get all the prime paths from the graph that is what we are going to see today so here is one algorithm i will instead of giving the pseudo code of the algorithm i am going to illustrate the algorithm on a running example in fact you all can take it up as a small exercise to see if you can write the pseudo code of this algorithm so consider the graph that is given here it has 7 nodes numbered from 0 1 and so on up to 6 node 0 is initial node node 6 is the final node this graph if you study it has tends to have two loops there is one self loop at node 4 and then there is one loop here from 1 to 2 2 to 3 3 back to 1. so this assume that this is a graph that you derived from some software artifact graph corresponding to a method or something like that computation starts at node zero initial node computation ends at node six final node and along the way there are two loops one self loop at four and one more at one two and three is it clear so now for this graph we are going to see and my test requirement is look for all prime paths enumerate all the prime paths achieve prime path coverage so how are we going to enumerate all the prime paths that's the algorithm that we are going to see so the algo our algorithm will is a brute force algorithm not efficient but it works for all practical purposes and it is a terminating algorithm that's all we need we are not bothered about efficiency and all that in software testing i will point you to a reference where you can get very efficient algorithms for enumerating prime paths for now we will just see a simple algorithm to enumerate prime paths as test requirement so our algorithm is just going to do this it is going to enumerate all simple parts in increasing length in order of increasing length and then amongst the simple paths it's going to choose prime paths from there so i have taken the same example put the same example that you saw in the earlier side earlier slide here on the left and remember what the algorithm is keep it in your mind enumerate all simple paths in order of increasing length and pick and choose prime paths from there that's all i'm going to do so this is the first step of the algorithm where i am enumerating simple paths of length 0 i am enumerating simple parts of length 0. what are simple parts of length 0 they are nothing but vertices or nodes in the graph so path i have just written it like this to emphasize that i am enumerating parts of length 0 so that is path corresponding to the node 0 path corresponding to the node 1 and so on path corresponding to the node six so there are seven simple paths of length zero which i have put aside and the right hand side for the graph on the left hand side out of these seven simple paths that i have listed in the last simple path i have put an exclamation mark if you notice here so why that exclamation mark is present the exclamation mark after part 6 implies that part 6 cannot be extended further that's also obvious because if you see there are no outgoing edges from this final vertex 6. so i make a note of that by putting an exclamation mark there that this i have enumerated all paths of length 0 which are basically vertices and amongst all parts of length 0 that i have enumerated i mark especially the parts that cannot be extended further let's say with an exclamation mark now my next step is enumerate all parts of length 1 so how many parts of length 1 are there they are basically the number of edges so i enumerate all parts of length 1 and i've grouped them together in this list so uh the first bullet if you see here path zero one and zero four are two parts of length one or two edges that originate from node 0 0 to 1 0 to 4. i have taken the vertex 1 and enumerated parts that come out of 1 1 to 2 1 to 5. so there are two parts of length 1 or 2 edges that correspond to parts of length one coming out of the vertex one then parts of length one coming out of the vertex two which is this path two three the third item in the list similarly path of length one coming out of the vertex 3 the fourth item in the list paths of length 1 coming out of the vertex 4 4 4 the self loop and 4 to 6 the edge and similarly paths of length 5 coming out i mean parts of length 1 coming out of the vertex 5 that is 5 6 and in the earlier slide i had 0 1 2 3 i had said path of length 0 starting from 6 cannot be extended i had already put an exclamation mark so in this parts of length 1 paths starting from 6 don't exist so this is all parts of length 1. first i did parts of length 0 now i am doing parts of length 1 and now again i am doing my marking so in this last part here path ending at six that is path five to six and similarly this path here path four to six i have put exclamation marks for the same reason there are paths that end at node 6 and they cannot be extended further i have also put a star or an asterisk in the path 4 4 this is different from an exclamation mark here structurally in the graph that path can be extended i can go 4 4 6 but i do not want to extend it because remember what my goal is my goal is to get prime paths prime paths are maximal simple paths this path is already maximally simple four to four it's already a simple cycle so because of that if i extend it it will cease to become a prime path my goal is to get prime paths so i said this path is itself a prime path and i leave it at that is that clear now the next step of the algorithm i enumerate paths of length 2. so i consider each path of length 1 that is not a cycle i have already marked cycles like this 4 4 with a star i am not going to consider them the remaining parts of length 1 which are all these first 1 0 1 0 4 1 2 1 5 2 3 3 1 and so on all these parts of length 2 i am going to take and each part of this length 1 i am going to extend it such that it a final node can be reached from that path right and i repeat this process by extending paths so at any point in time i have parts of length k i take some of them i mark out as the stars or exclamation marks so what is the convention convention for exclamation mark is this is it i can't extend the path anymore convention for marking a path of length k with a star is that the path is already a simple cycle the rest of the paths i try to extend it and mark them once again and this algorithm repeats for how long this the algorithm repeats till we reach paths of length mod v minus 1 where mod v is the number of vertices in the graph because remember as i told you in the last lecture we are looking at simple paths paths that do not contain internal loops maximum length of such a simple path can only be at most the number of vertices minus one right so this algorithm is guaranteed to stop so let us go on i had parts of length 1 in the earlier slide i am using those parts and writing out parts of length 2 so 0 1 2 is a path of length 2 0 1 5 is a path of length 2. they both were obtained by extending the path of length 1 which was the edge 0 1 similarly 0 4 6 is a path of length 2 and so on 1 2 3 1 5 6 2 3 1 3 1 2 3 1 5 right all these were obtained by extending these paths in this slide that were not marked with a star or a exclamation mark so those are these paths now i again do the exercise of is there a path that cannot be extended further put an exclamation mark keep it aside is there a path that is already a simple cycle put a star keep it aside by marking it as a prime path so here it so happens that two of parts of length two cannot be extended further that is zero four six and one five six so i keep them aside i don't need them so now simple parts of length three i repeat it so these are all the simple parts of length three zero one two three zero one five six one two three one two three one two two three one five three one two three three one five six i've just extended the parts that come here that were not marked with an exclamation mark to make parts of length three again i do the exercise of the parts that further cannot be extended mark them with an exclamation mark the parts that are already simple cycle mark them with a star so if you see a quite a few are marked with an exclamation mark parts that end at 6 0 1 5 6 and 3 1 5 6 they both are marked with a exclamation mark and parts that are simple cycles like 2 3 1 2 1 2 3 1 3 1 2 3 they are already prime paths so i keep them aside in fact in this list of parts of length three i just have one path here that i can extend two three one five sorry i just have one path here that i can extend two three one five that's it so i take that one path and i extend it with two what can i extend it to two three 5 6 let us go back and look at the graph 2 3 1 5 and 6 that's it it ends at 6 so this cannot be extended and you can continue this till every path till you reach paths of length mod v minus 1 and that's it we cannot do any more and keep marking it with exclamation marks and stars and this algorithm is guaranteed to terminate because i told you the length of the longest prime path is basically the number of nodes minus 1. so for this example it so happens that there are 32 simple paths out of which there are 8 prime paths obviously i am not listing the 32 simple paths but here are the eight prime paths so the ones that we had pulled out as stars and some of the ones that we pulled out with exclamation marks they will turn out to be the prime paths for a convenience for this graph on the left which was our running example here are the prime paths that are given on the right totally eight of them so path four four corresponds to visiting this simple loop ah self loop once zero 4 6 the second part in this list by now you can easily guess what does it mean it's a path that corresponds to skipping the loop at 4 path 0 1 5 6 the fourth path here 0 1 5 6 this path sorry this path corresponds to skipping this loop 1 2 3 loop 0 to 1 don't enter the loop 1 to 5 5 to 6 so it corresponds to skipping the loop parts 1 2 3 0 1 2 3 the third one in this list lets you enter the loop 0 to 1 1 to 2 2 3 right and as many times as you want you can visit this loop which are the parts that will help you to do these three prime paths one two three one two three one two and three one two three will help you go round and round the loop as many times as you want you can use any of them and finally when you want to exit the loop use this path 2 3 1 5 6 this one 2 3 1 5 6 the last one so what we have we done just to summarize our goal was we had a graph like this that we got from a software artifact that graph had some loops my test requirement was to get the prime paths out of the graph because i would like to skip every loop that is present and execute every loop that is present so the algorithm to enumerate prime paths that we saw will start enumerating simple paths starting from length 0 length 1 length 2 and so on and pick and choose prime paths as as it enumerates the simple paths so for this algorithm it so happens that there are i mean for this example so happens that there are 32 simple paths out of which eight of them happen to be prime paths that are listed in this slide once you have prime paths magically it so happens that how many ever loops are there in the graph there could be nested loops there could be separate loops as you see in this example every loop will be skipped and covered once or more than once that's the correctness about the prime paths example which i am not going to do the correctness so these give me what these give me all the prime parts in the graph so this gives me the test requirement for prime path coverage next comes test path so once i have the test requirement if you see these prime paths some of them if they already begin in an initial node and end in the final node then that itself becomes a test path like for example this one part 0 1 5 6 already begins in an initial node and ends in a final node so there is no problem this by itself is a test path you are done otherwise what we do is the following so here is an outline of the algorithm that will enumerate test paths for prime path coverage you start with the longest prime path and basically extend each such prime path to the initial vertex on the left and to the final vertex on the right for example you start with the prime path 2 3 1 5 6 for this example it was this last prime path that you saw here why do we start with the longest one because this will subsume some other some paths will come as sub parts of these so 2 3 1 5 6 is what i start with and i can extend it to i by appending with 0 and 1 because of the structure of this graph on the left and then i have to do one more iteration just to complete it so this will tour four prime paths zero one two three one two three one two three one two three one two three basically the path that goes round and round the loop you can use them up to your convenience to dictate the number of iterations in the loop this test path for example achieves two iterations of that loop as i told you earlier the prime path zero one five 6 is itself a test path that satisfies the condition and for the other loop 0 4 the self loop at 4 we have 0 4 6 which is itself a test path and then i can do 0 4 4 6 which would cover that path so if you see between the two test paths 0 4 6 0 4 4 6 for this loop and 0 1 2 3 1 2 3 1 5 6 for these three prime parts and 0 1 5 6 for the prime path that skips the loop i am done with prime path coverage so this is a rough outline of the algorithm basically what it says is start with the longest prime path extend it to the left extended to the right use any search traversal algorithm to extend to the left and extend to the right that will give you the test path so for that example we had five test paths for prime path coverage if you see the first test path visits the loop exactly once second test path visits the loop twice you could repeat it by making the loop this this segment no 2 3 1 2 one two three one you can repeat any of them to make the loop visit more than once the third test path skips that one two three loop this uh fourth and fifth test path cater to the other self loop at four zero four six skips the self loop zero four four six visits the loop any number of times here once but you could repeat it to visit any number of times so these are test paths they need not be prime paths test requirements have to be prime paths remember that that difference should be clear so these are prime parts they are maximal simple parts test paths meet the test requirement of prime paths they always begin and end with the begin at an initial vertex end at a final vertex they can have repetitions because they are just test paths that satisfy prime paths now you can ask for this example we had so many prime paths right how many we had eight of them eight prime paths and we came up with five test paths in this for this example that will achieve the test requirement of satisfying the eight prime paths can we come up with a shorter test set of test paths is this the most optimal in terms of the number of test paths you could ask questions like this because graphs sometimes can be very large the ones that correspond to ah real software and there could be several loops in the code there could be several different prime paths so things can get very large you don't want too many test cases as test paths so can i come up with an optimal number either in terms of the number of test paths or in terms of shorter test paths the the bad news is that such a problem is in general unintractable we while we know of some algorithms that might compute optimality we do not know of good polynomial time algorithms that will compute optimality so we usually do not try to get optimal test paths there are some very there is an important technique in testing called symbolic execution which you can use to get better test paths we will do symbolic execution later in the course so as i told you suppose you want to do it on your own with the help of instructor you in the next week i'll teach you how to generate graphs from methods and once you have the graph suppose you want to get prime paths as test requirements and want to get test paths that achieve prime paths as test requirement obviously you could deploy the algorithm that was taught in this lecture but if you want a shortcut go to this page this is the course page of the textbook by george mason university they have this app web app where you can enter the graph through the interface they have and that will give you the graph coverage criteria so let me just show it to you once so this is how the web app looks like so you can enter the graph edges here you can enter the initial node here you can enter the final node here and then this is a list of test requirements do you want node coverage edge coverage edge pair coverage covering simple paths covering prime paths they give two three different algorithms we saw algorithm one which is the slower one they have a faster algorithm and then you can get the test paths for these so this is a very useful web application try and use it so if you want to learn more this is the paper that you can refer to for getting test paths and test requirements for prime path coverage so i will stop here in the next lecture we will take examples of code and derive graphs out of them and apply structural graph coverage criteria that we saw in these two lectures thank you