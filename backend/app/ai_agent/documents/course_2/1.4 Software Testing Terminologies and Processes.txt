[Music] hello everyone welcome back we're in week one i'll continue with software testing terminologies and processes today and move on to doing test automation in the next lecture so we saw all the basic terminologies last week in the last class let's move on and look at what would be the goals of testing based on what an organization wants to do testing is usually heavily dependent on the nature of the software product that is being developed on the nature of the organization that is developing the software product how big or small it is and how mature they are in terms of setting up their quality processes so testing goals can vary to be absolutely trivial to very mature based on how processes of a particular organizations are mature so this small module will tell you what would be the various testing process maturity levels as far as software development and testing is concerned so level 0 is absolutely low level there is absolutely no difference between testing debugging anybody is free to do what they want to do followed by testing at level 1 where people think that the purpose of testing is to show that their software product is correct it goes on till levels four as you can see in this slide at level two the purpose of testing converts to showing producing and showing errors or defects or bugs at level three the purpose of testing is a little more sophisticated you know i use testing to show a particular module has bugs i rectify the bugs to say that the module is now free of those bugs so there is a bit of testing used to show correctness this is mature it's repeated there are distinguished testing teams and my overall goal is to show that the software works pretty fine the risks of using it are much less level 4 where large organizations exist is the most mature level of testing where the quality and testing processes are so mature the testing becomes a part of the mainstream work of a developer and all developers including testers use testing extensively to develop high quality software so let's look at each of these levels little by little so if i'm at level 0 thinking typical example is somebody who's just got a cool startup and he or she is trying to work on a software and they their goal is to try and get the product out as early as possible so they try to debug obviously while they code they don't maybe go through an exclusive testing phase they don't have mature well-defined processes for testing and things like that so it's the same as debugging whatever the developer does to ensure that his or her code works correctly which is debugging the code becomes the same as testing no exclusive efforts devoted for testing and we move on so while this helps it does not give a proper confidence does not ensure that the software is fully reliable or safe the next comes level one thinking where the purpose is slightly misunderstood developer tester thinks that the purpose of testing is to show correctness but on the other side as i told you earlier using testing is almost impossible to make a statement which says that my software is fully correct so correctness is impossible to achieve using test testing because the only thing that we can do with testing is to identify faults and errors and the purpose should be to identify faults and eliminate them and retest so if i had set out by using testing to show correctness then i'm not following the right path the next one is level two thinking where testers and developers are consciously aware of the fact that the goal of testing is to find errors by showing failures in the software and but it's sometimes mistakenly viewed as you know i have i am a developer he or she is a tester they found an error in my code that's bad you know their processes are not mature enough to say that finding errors while testing is good for your software because you can rectify them and ensure that it's correct so while they consciously realize that the purpose of testing is to find errors it's not yet mature to accept testing as a robust rigorous process to find and eliminate errors the next is level 3 thinking where testing is consciously considered by everybody both developers and testers as a robust technique that is known to show errors and bugs known to detect faults right so everybody is aware of the fact that when i write code when i use the code when i run the code i am taking some risks the code is bound to have errors the earlier i find it as and when i'm writing as and when i'm testing the better it is if i release the code before finding a particular bug and if it's found after release then it is risky so testers and developers work in cooperation to find as many errors as possible and eliminate them fix them and reduce the risk of the software being defective after release many organizations typically are at this stage level four is the most mature process oriented concept for testing so if you are in an organization that practices level four thinking as far as quality and testing processes are concerned what is testing testing becomes a mental discipline it's a part of your job that you do to routinely test your code subjected to quality audits and it's the only way that is known to increase the quality of your software module and the ultimate software products test engineers are developers they become active components and leaders in the project and their primary responsibility is continuous improvement of quality which involves in turn continuous measurement of quality measurement of quality involves finding and eliminating defects keeping track of the defects ensuring that they are reduced over time as and when a software is mature so that is level four thinking now as far as this course is concerned how does it matter that was this theoretical thing that we spent a few minutes understanding about testing process levels but how does it matter as far as this course is concerned the first thing is it's important for all of you to know that there are something called testing process levels and based on the process level that the organization that you are in is a part of the goals of your testing the kind of testing that you do will drastically wait so we in this course are going to deal with all the technical and algorithmic aspects of testing that will help for level 3 and level 4 thinking where there is maturity as far as testing is concerned so this course will help you to write test objectives what is my goal why am i pursuing testing what is it that i am going to do while testing a particular software module it will also help you to design understand and implement what it means to achieve coverage in code so i have a large code base that i have developed let's say a few thousand lines of code may be much more than that how do i systematically go about testing this code how do i plan for it and what do i say i am testing this code for what are the properties what am i trying to achieve or cover with testing the same holds for design the same holds for requirement documents this course will teach you how to test design documents how to test requirements how to test preconditions post conditions and how to test code both at the white box and black box style you learn all the algorithms that you can that will be used for testing so that was about process levels the second module in this video is about one concept that i would like you all to understand before we move on to actually designing test cases that is the notion of controllability and observability they are two very important concepts in software testing so let's see what they mean so what is controllability so if you take the english meaning of the word something is controllable i have control over it so what is the thing that you need control over as a tester let's say you are testing a particular software module a particular code base it could be one whole class it could be a fully packaged software it could just be one method or a procedure inside a software so controllability is about how as a tester you can provide inputs to the software module that you are testing run the software module on the test inputs that you have provided and get it up and running now the next part okay i have given inputs to my software module under test the software module is running on my inputs what does the software module do it finishes executing on the inputs and it will produce some outputs right so i should be in a position to observe the outputs to record the outputs study them and come to a conclusion about whether there is an error in the software module by studying the outputs that are produced so you have a software module under test just to repeat so that could be a full piece of packet software a class or a method i give inputs to that software module such that the part that i am interested in is exercised is run executed or tested that's controllability and when the software module runs it produces some outputs so the parts that i do to produce output is called observability so these two put together make sure that your testing is successful that i test my software module make it controllable make it run on the test input and then i produce outputs for the software model so let's understand with an example what is controllability and observability let me illustrate through a simple example what i mean by observability and controllability so let's switch to the whiteboard for a minute i hope all of you can see the whiteboard so we would like to understand controllability and observability okay these are the two concepts i would like to know what it is sorry so let's say the module that i want to test is a method let's give it a name okay so let's call it my method it has some arguments okay and then it has code let's say it has line 1 of code then line two of code i'm not writing code but assume that there is code and then a few lines and let's say after this there is a if statement so if something happens then you do something and then there are more lines of code and then there is an else statement here and then there is more lines of code here okay and then as a part of this let's say there is a while loop as a part of the else which is inside the if there is a while loop and then there is code here and what i want to test is whether this loop is working correctly ok this is the module that i want to test as a tester i suspect or as a developer i suspect that there is something wrong in this module and i would like to test it now you understand what the problem of observability and controllability will be i have to first reach this method called my method that itself could be somewhere inside the code and then i have to go execute all these statements come to this if statement and what will happen to the condition of the if statement this should fail because i need to go and execute the else part of the if statement which has a while loop inside that which is the unit that i want to test so i have to first reach this method reach this if statement fail whatever the condition of this if statement is i have to that condition should return false which will enable this else part to be executed and this while part should be reached i should reach here okay once i reach this then i can test this so for all that you know this while part the the variables that are involved here right they may not even be inputs there could be some other set of variables that are here these could be different variables so the idea is i have to give what are test cases they are basically inputs and expected outputs i have to give test cases which are basically inputs that my method this method can run on reach the if statement the statement should reach the if statement reach the if fail it it should return false and then reach the while statement which is nested inside the if right so if i do this this is called controllability i have succeeded in giving inputs that are able to reach my module under test now i run this while statement okay after i run this while statement there might be a few other pieces of code right so it goes on like that it goes on like this and sorry i just need to open the anyway so it goes on like this and after this i should be able to observe my outputs observe and record outputs once i do this this part is called observability is this clear what controllability and observability means so this was a simple example to illustrate what controllability and what observability are so let me go back to my slides so this is what i meant when i said the method that i want to test or just the unit of code that i want to test can be hidden deep in the code and may not accept any inputs directly so as a tester i have to ensure that the module under test is reachable it can get infected and whatever output that it produces as a unit of code eventually propagates and becomes the output of the software that as a tester i can observe so usually people do it manually observability and controllability they work with a test automation tool where i can do my prefix and post fix annotations as we call it and get the automation tool to manage these properties of reaching the segment of code to be tested and letting the outputs of that segment of code trickle down as outputs to the software the test automation tool will provide prefix and postfix annotations for you to be able to do it or you could do it manually in this course we will learn a couple of techniques for this but remember when i'm testing the module that i want to test could be anywhere in the code and as a tester my job is not only to test the module to see how it is but in that process i also have to be able to first reach the module that is what we call controllability and exercise or execute the model and then move on record the outputs and observe what happens so these are very important properties that i need to follow for testing so with this in mind the next module i will teach you the basics of one test automation tool that we will be using throughout the course the tool is called junit we will learn junit from a theoretical point of view and along with the instructors you will learn how to use it along with the ide that you are going to be able to test a real piece of software that you are going to use so i will stop here for now with the basics in the next class we will teach test automation thank you