[Music] hello everyone welcome to week two this is the first lecture of week two as i told you last week we are going to use a lot of standard data structures and other entities from computer science and elementary mathematics for designing test cases one such data structure that we would use extensively throughout this course is that of graphs we are going to learn several algorithms that will design test cases based on graphs so to make this course complete what i will do is introduce you to those entities and data structures in a brief way as it is relevant for software testing as and when we move on in the course so in this module we are going to learn about the basics of graphs as it is used in software testing later this week we will learn some graph algorithms if you have already done them there will be a good recap for you and then see how we can get started with using graphs for software testing graphs are a very ancient data structure graph theory is said to have originated in the year 1976 with this mathematician called leonard euler who is believed to be the father of graph theory it so happened that there was this city in konigsberg which is modern day russia which had seven bridges and the problem was about can somebody traverse through all the seven bridges in such a way that they visit each bridge exactly once euler later showed that this is not possible and this is how graphs are believed to have been invented now graphs are an important entity not only in computer science and data science but they are also extensively used in several other fields including sociology economics sciences including chemistry and biology in this course we will not learn a lot about graphs but we will learn the basics as we would need for software testing so what is a graph you should not be confused with what we write on a graph paper with an x axis and y axis those are plots a graph is an entity that looks like this picture that you see here on the bottom left or an entity that looks like this picture that you see on the bottom right so a graph has two kinds of components one represented by the set v is the set of nodes or vertices those are the circular entities that you find in these two figures here and the other one represented by the set e which is basically a subset of v cross v that is the cartesian product of the set v and v the set of vertices is the set of edges so if you see in this graph on the left there are five vertices u v w x and y we've just named them you can also name them as 1 2 3 4 5 or a b c and so on just give some name to the set of vertices just so that we know which is which vertex in the graph that you see on the right there are three vertices p q and r again we have named them as p q and r what are edges in the graph that you see on the left hand side let's count the number of edges there is one edge from vertex u to vertex b represented by this line horizontal line that you see going from u to b there is one edge from vertex u down to vertex w in this vertical line there is one more edge going horizontally from w to v there is one edge from u to b there is one more edge from x to y if you see this graph has no edge from vertex b to vertex y no edge from u to y no edge from w to x so the set of edges e is only a subset of the set of vertices v is this clear so based on whether we attach a direction to an edge or not a graph can be directed or undirected the one graph that is there down here on the left is an undirected graph why because there are no arrows or directions attached to edges whereas if you see this graph on the right it is a directed graph which means how do i interpret it as there is an edge from vertex p to vertex r and it has a direction it is in the direction from p to r so there is no edge from r back to p is that clear similarly there is an edge from p to q or there is a directed edge from p to q but there is no edge from q back to p this kind of edge that you see that is sticking itself to the vertex r is a special kind of edge we call them as self loops or loops so it's an edge from r to itself is this clear so directed graph edges have directions in them which means edges are an ordered pair of vertices in an undirected graph edges represent an unordered pair of vertices so for example if i take this graph on the left there is an edge from u to v it could be interpreted as the edge from u to v or the edge from v back to u it does not matter whereas here on the directed graph if i say there is an edge from p to r its unidirectional the direction is from p to r is this clear so the edge is ordered in a directed graph has a direction edges unordered in an undirected graph has no direction graphs can also be finite or infinite the graphs that we saw in the previous slide these ones here are finite because for finite graphs the number of vertices should be finite in number both have finite number of vertices infinite graph have infinite number of vertices theoretically they are useful not for the purposes of software testing so we will use finite graphs in this course one more concept simple elementary concept that you have to remember in graph theory is that of a degree of a vertex degree of a vertex basically counts the number of edges that are connected to it so let us go back to the previous slide let us take this graph let us take the vertex u how many edges come out from u there is one from u to v one from u to x and one from u to w so the degree of the vertex u is 3 is this clear the degree of vertex y similarly is 1 degree of vertex v is 1 degree of vertex x is 2 and so on for directed graphs the degree gets split as in degree and out degree like for example the out degree of the vertex p which counts the number of edges that go out of the vertex p is 2 because there is one directed edge from p to r one directed edge from p to q the in degree of vertex p is zero the in degree of vertex r is how much three because there is one edge coming from p to r one edge coming from q to r and one edge from r into itself the out degree of the vertex r is one so that is the notion of a degree we say an edge from u to b is incident on the vertex u and is also incident on the vertex v degree of a vertex is the number of edges incident to a vertex for a directed graph degree gets split as in degree versus out degree that is what this slide has it says the degree of a vertex is the number of edges that are connected to it edges connected to a vertex are said to be incident on the vertex then one more notion this is very specific to areas like testing in general graphs need not have designated nodes that have special properties but typically when we consider graphs in testing we consider certain nodes as initial nodes and certain other nodes or vertices as final nodes of vertices basically initial vertices or initial nodes indicate that something begins from there maybe the computation of a method or a program begins from there so it is marked like this by an incoming arrow like here in this graph u is an initial vertex and in the graph on the right p is an initial vertex for a final node we it represents something ending there so for example for this graph w is a final node it is marked by this double circle in the graph on the right r is a final node it is marked by this double circle border so it means some computation or something is ending there initial vertices and final vertices are designated vertices where typically from an initial vertex a computation begins and from a final vertex a computation ends typically there is only one initial vertex because many software is so called deterministic so we do not have two three places from which a software can start it always starts from one statement that could be an initial vertex and it could it could end in many of the several places that are possible for it to end based on the execution that it takes so there could be more than one final vertex our graph models for software artifacts that we use for testing will typically have initial and final vertices so why do we need why are we studying about graphs why do we need them in testing as i told you graphs are one of the most popular data structures used in testing you will learn how to use them and we learn several different kinds of graphs for testing we learn what we call control flow graphs data flow graphs graphs that represent call interfaces between methods call graphs graphs corresponding to uml diagrams like state machines state charts use cases activity diagrams and so on and so forth of course these graphs are not going to look as simple as this with some abstract numbers or letters as labels and edges having nothing in them they will always have several different annotations that represent various properties of software artifacts these annotations will come as labels that are associated with vertices or edges we will learn as we move on and we are going to design test cases that are meant to cover some property of the graph or the other which in turn means covering some property of the software module under test so here is one such graph ok focus on this code snippet on the left its just a fragment of code does not represent full executable code it represents some code of an if statement so it says if x is less than y then you execute these two statements y equal to zero x is x plus one else you execute the single statement x is y plus one and then you say ok after this if is executed z is x plus one so it's just a fragment of code so for this fragment of code suppose i have to draw the control flow graph which is abbreviated as cfg in this title how will it look like it looks somewhat like this graph that you see on the right so this point here that has this incoming arrow represents this if statement this if statement is represented by this node this node and then there is a decision point it checks for the truth value of x being less than y if x is less than y it takes the left edge and goes to a node which represents the two statements inside the then part y is assigned zero x is assigned x plus one if x is not less than y that is if x is greater than or equal to y or the condition of if is false then it takes the else part and it goes to this statement where x is equal to y plus 1 right so that is this node on the right whatever it is it is one of this will be executed and after this the last statement z is equal to x plus one will be executed we will learn this more thoroughly properly this is just meant to be an illustrative example for you here is a second example suppose we had an if statement without an else part so if x is less than y then you do this y equal to zero x is equal to x plus one get out of the if and then execute the statement z is equal to x plus one how does the control flow graph for that look like it look like this graph on the right so there is an entry point there is only one part of the if statement which checks if x is less than y this condition here which corresponds to this condition here if it is true then it goes ahead and executes these two statements they are clubbed and put together in this one node and after it finishes executing or even if the if statement is false it goes to this last statement which is z is equal to x plus one that is represented by this node here below is this clear so this is just an example as i told you do not worry we will see the same thing in detail little later so few more concepts from graphs that you would need for the purposes of software testing so one notion is that of a path so how do you define a path take a graph by now you know what it is start from some vertex put yourself in as standing in some vertex or keep a pebble there in one vertex then take an edge that goes out of that vertex where will you reach you will reach the second vertex some vertex that the edge is going into then you are in that vertex then take another outgoing edge from that vertex you will reach the third vertex and then take another outgoing edge from that vertex you will reach the fourth vertex that's all you do so a path is basically a sequence of vertices us say v one v two and so on up to v n such that two consecutive vertices at any point in time that is v one and v two v two and v three in general v i and v i plus one are related by an edge so let us go back a little top and yeah maybe we look at this graph this graph so can i trace out a path in this graph so i can start at vertex u take the edge from u to x go to x then take the edge from x to y go to y and stop because there's nothing going out of y i have to stop at y the path ends there alternately i can start at let's say v vertex v take the edge only outgoing edge from v to u reach u go to w reach w then take this edge w to x go to x and then maybe take this edge x to y go to y and stop so that's another path so i hope you understand what a path is so a path is a sequence of vertices such that i can hop from one vertex to the other in the sequence in order by using edges that connect those vertices in the graph i need also need the notion of a length of a path which basically counts the number of edges in the path for length of a path we don't count the number of vertices we count the number of edges you have to remember this a path can have smaller parts inside them such smaller parts are called sub parts like you have a set and a subset you can have a sub path of a path which is basically a sub sequence of vertices which is a part of that part which occurs as a contiguous sequence so in that same example there is a path which is u w x u v vertices can repeat in the path no problem and it gives a sub path ok so this is another notion that we will need then there is a notion of reachability so how do i say some vertex is reachable from some other vertex i say one vertex is reachable from the other vertex if there is a path connecting both of them simple enough right so let us go back and look at the same example sorry moving back and forth in slides so here i can say vertex y is reachable from vertex u why because there are several parts that connect u to y i can go from u to w w to x x to y i can go from u to x x to y that's fine but in the graph on the right suppose i ask you the question is vertex q reachable from vertex r i'll repeat is vertex q reachable from vertex r the answer will be no because if you see there is no path that connects r to vertex q but suppose i ask some other question suppose i say is vertex p reach is a vertex r reachable from vertex p what is your answer the answer is yes because i can find two parts one is the direct edge from p to r which is also a path the next is the edge from p to q and q to r is this clear so that is the notion of reachability so let me go back to the slide on reachability yeah so we say a vertex b is reachable in a graph if there is a path from one of the initial vertices of the graph to b this initial vertex is just an extra condition you can say that a vertex v is reachable from a vertex u that's also fine so just as we talk about reachability of vertices we can also talk about reachability of edges so we say an edge is reachable in a graph if there is a path from one of the initial vertices to the vertex u and then to v the edge connects u to v fine then the notion of a sub graph sub graph is just a smaller graph of a graph so you can talk about an entire sub graph being reachable from an initial node if one of the vertices in the sub graph is reachable we may not use reachability of sub graphs but we will use reachability of vertices and reachability of edges ok fine so we now understand what is reachability how do i know whether a particular vertex is reachable or not are there algorithms to solve for reachability yes there are there are two popular basic algorithms that serve as a backbone for several reachability problems related to graph theory one is depth first search the other is breadth first search depth first search abbreviated as d f s breadth first search abbreviated as b f s so we will use bfs and dfs as well known algorithms that can be used to talk about reachability properties in graphs so we will use them for testing also because we are going to use them for testing irrespective of whether you have done it in the past or not in the next module i will reteach depth first search and breadth first search from a standard textbook most reachability problems can be solved using variants of depth first search or breadth first search so it is useful to know these two algorithms fresh as a part of this course we will do it in the next module a few more concepts and graphs before we wind up for today for this module the next one is notion of a test path we saw what a path is part can start from any vertex and end at any vertex it can only be of length one in which case the path is just one edge a test path always starts from one of the designated initial vertices and ends at a final vertex so a test path is a path that starts in an initial vertex and ends in a final vertex intuitively it makes sense to start in an initial vertex because that's where computation of your software module under test is going to begin it also makes sense to end in a final vertex because that's where the computation of your software module under test is going to end is this clear test paths always will come because you are executing some test case we will make all these things clear so if i get the test path as a result of executing a test case then the test path becomes a feasible test path sometimes somebody might have a goal of can you illustrate this test path for me but you will realize that you will not be able to find any test case that will result in such a test path in that case we will say that the test path is infeasible we will see examples of all of these as we move on in the course then there is notion of when it comes to test path in software testing we distinguish subtle notions about visiting and touring in english it might be the same thing but ah in testing as far as graphs are concerned we distinguish them in some way so here is what the definition says so we say a test path p visits a vertex along the way if v is one of the vertices that occur in the path a test path p visits an edge e if e is an edge that occurs in the path it just comes as a part of the path a test path p towards a sub path q if q is a sub path of p is this clear strictly speaking every vertex is sub path every vertex that occurs in a path is a sub path trivial subpart of that path every edge that occurs in a path is also a trivial sub part of that part so touring and visiting are one and the same for vertices and edges is this clear so this example just talks about the same thing you take the graph that we saw earlier we saw that there was a path u w x u v so if you see this visits how many vertices what are the vertices that occur in the path vertex u w x and v it also visits the edges u w w x x u and u v and it tours a sub path for example w x u it could also tour the sub path x u v and so on is this clear so the last notion so when a test case that we give executes a test path we call the test path executed by path of t this is another fictitious example let us say you have a graph that looks like this and node 1 represents some i mean node u represents some kind of branching this is when a is less than b this is when u to w is when a equal to b u to x is when a is greater than b so for example you could give test case values for a and b so suppose you give some value where a less than b is true then it might take the path u v w x which is the first one a 0 and b 1. suppose you give some value where a is equal to b say both are 1 then it will take the path u to w to x test paths always begin at an initial vertex and end at a final vertex please remember that suppose you give a test case value where a is greater than b then it will take the test path u to x the it's just a trivial path with just one edge in it yeah so what we defined reachability for which we will see algorithms in the next lecture was purely syntactic in the sense that we do not know what the underlying graph was we just take the graph we do not know where it came from then we talk about reachability when it comes to testing we will worry about reachability by using test cases as i told you please remember the notions of observability and controllability that i told you right observability means coming from the initial vertex to a particular vertex controllability is from that particular vertex going to a final vertex because initial vertices represent places in the code where you can give inputs final vertices represent places in the code where you can observe the outputs that are produced so we will use reachability from the point of view of test cases executing as test paths and consider feasible test paths the ones that are infeasible will be unreachable for us all these things we will see for specific graphs as we move on so as i told you we will use several different kinds of graphs which we are going to define as we move on so what we are going to do is we will learn how to develop a model of a software artifact it could be a piece of code it could be a requirements document anything so we learn how to take that and write a graph out of that if you use an ide you can help use the ide to get the graph many ides intellij eclipse visual studio they all have features to generate control flow graphs for you so we will develop a model of a particular software artifact as a graph those graphs can have several parameters they will have initial vinyl vertices they will have annotations as i told you then they will sometimes when you look at data flow graphs you can annotate specific vertices or edges with values of variables with conditions on variables and so on and then we will use reachability algorithms to work with testing of these graphs so that is what we are going to do one last bit before we go on just as an example we will see this more formally in the subsequent modules so we saw these things earlier so a test requirement is for example you could say cover every if statement in a particular piece of code so that is your test requirement somebody tells you what to test for somebody might say cover every loop test every loop in your method that could be a test requirement so it describes some properties to be tested some properties of test paths then a test criterion a test criterion is basically rules that define test requirements somebody telling you this then we say given a set of test requirements for a criterion c let us say cover every loop that's the criterion and there is a set of test requirements for that our goal as a tester is to write a set of test cases that satisfy this criterion c i can cover every loop right and i say such as test set of test cases satisfies this criteria c if and only if for every test requirement t and tr there is a test path that meets the test requirement t for example you take this graph that i showed you earlier this has four vertices u v x and w so many edges some of them have labels like for example you can take the implicitly read this as u is the initial vertex x is the final vertex you can take the edge from u to v provided a is less than p you can take the edge from u to w provided a is greater than b a is equal to b sorry you can take the edge from u to x provided a is greater than p so based on the test case i give whichever of these conditions is satisfied that edge will be taken suppose i give three test cases as given here one for each kind of condition one for a less than b one for a equal to b and one for a greater than b then what have i basically covered i have basically covered all the three edges that are coming out of you i have defined test cases that will execute all the three parts that are coming out of you this case i mean it as to say i have covered all the branches that go out of the vertex u or in other words i have done branch coverage for you this is just an example i will formalize this for you so we will look at coverage criteria that are purely structural without any prop worrying about any variables the types where do they come from nothing we'll just define graphs in terms of vertices and edges and define coverage criteria first to start with that's this week we call that a structural coverage criteria next week we will start worrying about variables annotating the vertices or edges with those values with conditions and worry about flow of a variable from its definition to its use so we call such coverage criteria as data flow coverage criteria we will see them in the next week so these would be coverage criteria that we would see if you would like to know more about it you can refer to this textbook which i have given as a reference so i will stop here for today in the next module we will do depth first search and breadth first search thank you