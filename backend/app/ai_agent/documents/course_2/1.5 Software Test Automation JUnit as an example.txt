foreign [Music] welcome back this is the last lecture of week one while we are going to learn a lot of theoretical algorithmic Concepts in testing ultimate goal in testing is to be able to design a test case yourself and try to execute it so for that you need tools you need test automation support and there's one very popular well used open source tool called junit which I will teach you through this example as we move down the course in subsequent weeks as and when we learn various kinds of testing various algorithms for test case design wherever relevant you can try to design those test cases using the algorithms and execute them using a tool like junit I'll walk you through the basics then I'll share the website of J unit tell you what it's all about and you will get to do assignments through the course wherever that is relevant using junit a lot of this learning on junit is practical in nature where you learn by solving questions and by experimenting yourself what I'll be doing today now is just a theoretical overview of what junit is so after we've designed test cases and we are ready to execute your test cases you need support with automatic automating the execution so that process is called test automation so test automation remember test case needs to go to a particular place if you're going to test a particular fragment of code and whatever that particular fragment of code outputs need to propagate to the output and so on so this is what we learned as ripr criteria and one of the earlier lectures so the way we do our IPR in test automation is to give what we call prefix values and post fixed values prefix as the name says helps you to reach the fragment of code that you are trying to test post fixed values will ensure that the output of the fragment of code that you are trying to test those values do propagate and end up in the software producing the output so as the summary definition test automation is the process of controlling the execution of tests comparing the actual outputs produced by the software to the expected outputs that you had written as a test case designer setting up these prefix values post fixed values other ways of reporting and so on this entire process is test automation so remember what we saw as a test case we said simply test case was inputs and expected outputs if the actual outputs match the expected outputs we say the test case had passed otherwise the test case had failed now in addition to that suppose the code that you're testing is embedded somewhere deep inside the overall software that you have you need to give prefix values and post fixed values so let's see what they are prefix values are basically the inputs that are necessary to put the software into an appropriate state so as to be able to receive the test case values The Other Extreme is postfix postfix values are inputs that have to be sent to the software after the test case is sent to make sure that the remaining portion of the code gets executed and the output is produced so they could be verification values which are values needed to see the result of the test case execution or they could be simple exit values which ensure that the execution completes and the program terminates normally so a test case that is ready for execution unlike a test case algorithmically includes the following the actual values of the test case prefix values and post fixed values as necessary and expected results or outputs that are necessary to complete the execution and evaluation of your module under test when I get a tech executable test script the test case is prepared in a form that can be executed automatically on the software and a report can be produced about the test case passing or failing so junit is a tool that will help you to do this it's open source testing framework for Java it can be used to write design and run automated tests and this whole process can be repeated several times we will specifically look at junit but corresponding unit testing Frameworks exist for several other programming languages so junit is an instance of what we call an X unit architecture X could represent some other programming language instead of J for Java and it represents a generic test execution automation framework for unit testing junit is itself available as an open source tool from junit.org towards the end we'll open the website and walk you through that it's basically a structure for writing test drivers junit can be used to test Standalone Java programs from your command line or it can be used within Ides like Eclipse Intel IJ netbeans Jupiter notebook Visual Studio code and so on so what are J unit has several features this is just a snapshot of some of the important features one of the core features of junit is the notion of assertions assertions help you to write whether if I do a test case execution what would I expect as a result of that execution we will see several examples of how to write different kinds of assertions it's basically like a Boolean predicate that will return true or false in addition to that junit will support several different test features for sharing common test data and test inputs it also supports test Suites for easily organizing and running tests and it has as I told you graphical text Runners test Runners textual test Runners and it can run from within an IDE so tests in J unit can be used to write test cases for testing an entire object a part of an object like a method or some methods with their call interfaces or it can also be used to test for interaction between several different objects primarily used at the level of unit testing and integration testing typically not for system level functional or non-functional testing you need some other tools for that each test in junit is embedded into what we call a test method and test methods are organized grouped into a test Class A test class includes a collection of test methods methods that can be used to set up the state before and update the state after each test executes or sometimes after all the tests execute so how do I write test cases for junit there is a particular class called junit dot framework.asset based on your IDE the name of this class could be different use the methods of this class each such test method will contain an assertion which is basically as I told you a predicate or a condition that returns a Boolean value and it will report to the test Runner about whether the test case is failed or succeeded you could write various kinds of assertions to check for yourself whether a particular test case has succeeded or failed test Runner as I told you is basically used to report the results to the tester or the user all the methods in junit will return void for example I could write something like this this is one kind of assertion I say assert true a predicate or an expression that returns a Boolean value so this for example could mean if a function is supposed to add then you pass two arguments for addition for that function and check if it Returns the correct value as the result of those addition and if it does then this Boolean value that the assert true will return will be true so the whole test case passes otherwise the Boolean value that this assert would return would be false and then you can infer that the test case fails you could also add some comments to such an assert true so you say if this Boolean value evaluates to be true then you print an argument like this string as output like for example you could say test case has passed as the string to say that the assert is returned correctly the value or you could say addition is happening correctly it's just a comment that you add to uh which will be displayed in the console obviously as a tester to understand whether the assertion is passed or failed this is another kind of assertion so it just says fail it means that if something fails then you output the string output a message that the string contains we will see some examples as we move on the other things are test fixtures in J unit a test fixture as I told you helps you reach the place that you want to test and come out of the place that you want to test so it is basically the state corresponding to a test it includes objects all the variables that are used by the tests that you're considering typically not one we write more than one tests it includes the prefix values which are used for initializations it includes the post fixed values which are used for reset different tests can use the object without sharing a state objects used in text fixtures should be declared as instance variables they should be initialized there are two kinds of methods several others this is just a sample one is before each and the other is at beforehaul this is for the prefix and for the Post fixer reset values you do at after each or at after all here's a small toy example as I told you just a little while ago suppose we've written this calculator program which has a method for addition and it takes two integers and Returns the sum so this is the program how do I write a test case in junit for this the current version of junit as you would see in the website shortly towards the end of this lecture supports junits integration with Jupiter so I have picked up this from that website so you will have to do this you'll have to call this assertions particularly assert equal this calculator is available in your utils and this is the thing uh this thing for Jupiter and this is the class and then you say calculator is this and then you write this method called ADD test so what does it do it basically says pass values 2 and 3 to this method called calculator dot add and check if it returns five if it works correctly it should return 5 and so the result of this output will be equal to 5 then assert equal will say OK these two values are equal so the test case is passed this assert equal will fail will return false if the actual output is not 5 when I pass 2 and 3 in which case you say that the test case is failed and it could indicate that the method that is used for addition in calculator could be a wrong method similarly another example to walk you through how to use assertions let's say I have to compute the minimum of set of numbers so then first I import these things this is not specific to Jupiter uh notebook General General Imports each could vary based on the ID that you use and then you write your prefix and post fixed values prefix values could be written like this it's an array list post fixed value just say stare down which is called after every test method so here is a test case for checking for minimum that uses the fail assertion so it says list is null it's a try catch exception and it says the minimum is the minimum of list and if it's null then it'll say you fail because null pointer exception was expected and that didn't happen so this is an example of how a fail assertion is used similarly suppose I pass an empty element and compute minimum for that here is a test case that will say I expected a null pointer exception class and it this is how the test looks like so you can go on writing different different kinds of tests we'll see more examples directly from the website you can also write data driven tests what do I mean by data driven test is suppose you wanted to test calculator like we saw earlier that simple test that we wrote just passed two values I mean one test case that has two values two and three and a check for five maybe you would want to as a curious tester test it for some more value if it adds any number to 0 will it return the same number can it add negative numbers correctly things like that so you might want to pass a set of test cases to the same method simultaneously without writing each time elaborate things so that's what we call data driven tests they basically immune in junit they call a Constructor for each collection of test values and then the tests are run for each set of these test cases and then a result is produced so you we will see how to do it so we've highlighted what we've done now is I have just got you started on junit just the basics of it we've highlighted search and features towards illustrating its use in test automation remember it's a full-fledged tool that is up to date and it has several other automation features even though it's open source it's used widely in the industry so what I'll do now is let's go to the website of J unit and I'll walk you through what it has so this is junit currently the version that is up and running is the fifth version as it says it's for Java but you could pick up the same thing for other test cases so so let's go down there are these main things in the website so I would like to walk you briefly through parts of this user guide so this is the user guide if you see the entire table of contents is here it's a fairly large user guide it tells you what junit 5 is all about junit 5 is actually junit as a basic platform plus junit for Jupiter notebooks and junit vintage which basically shows backward compatibility if you had or used or are familiar with using earlier versions of junit you could do this so it has several different I mean I encourage you all to read through this website unfortunately we will not be able to go through line by line of this website but you can write several projects so this is the thing that I told you about suppose you had to write a test case in J unit this is exactly what we saw in the slides right I had passed two and three here they have passed 1 and 1 and checked if it is equal to two so this is like a first small test case that you could write for yourself using junit this assumes that you're using Jupiter if you want to use Visual Studio or Eclipse down this page you will know how to write the same test case for that framework instructors also have a whole set of interesting assignments which will help you to do this you could write simple annotations junit supports several kinds of annotations for configuring and extending their framework ADD test is what we saw basically denotes that a method is test method you could have at parameterized test repeated tests when you want to do regression testing you could have a test Factory test template so on and so forth several different things are there I briefly told you about these methods at before each at before all at after each and art after all remember that these are used for our ripr criteria at before each or at before all tells you what should be run before you test reach the main portion of the code that you want to test add after each and at after all tells you what to run after you finishing executing the main portion of your test so several other annotations are there and then comes this uh yeah so let's move on to test classes and methods so as I told you act test was one thing then what else is there so here is a standard example of a test class so this is again specific to jupyter notebook later in the same website you will see how to write it for eclipse or Visual Studio or Intel IJ idea so you have to import the respective methods the respective classes and this is the standard test so at before all at before each at tests at tests that succeeds and fails with a failed assertion that we saw ACT test can be used in several different versions like skipping aborting a test then after each and after all are the post fix or the tear down methods that we saw then you have display names like for example as I told you right you might want to print something and you in fact you can print a whole set of things how do you do that like you write like this so test classes and test methods can declare custom display names via this act display name you can do all kinds of things you can do simple things like this custom test name containing spaces and write it like this you could put some complex special characters like this you could even write emojis like this whatever you want then yeah so there are several kinds of display name generators and let's move on to assertions which are important part of learning how to program with a tool like junit as I told you assertions form the core intelligence of junit and you could you do the same functionality that you want to do using several different kinds of assertions so here for example there is assertol assert equals assert not null assault throws assert timeout timeout preemptively assert true this is still a sample the whole library of asserts are there and this code will tell you how to add so this standard assertions uses assert equal so it says if you call the function for addition in the calculator and pass it 1 and 1 it should return two if you call the function I'd again multiply if in the calculator and pass it 2 and 2 it should return 4. and similarly if you say is a less than b then you say that a sir true is possible similarly you can group assertions like for example you could say Jane you could say do a first name get last name you could have dependent assertions what is happening starts with ends with you could use assertion for testing exceptions like division by zero you could use assertions for testing for timeouts various kinds of timeouts you could use assertions just to write your first hello world junit program also right so that was the part about assertions please go through it I'm just walking through it quickly and for different languages they have different kinds of assertion supports the next important thing that I would like to highlight in this website is that J unit also has support for what we call conditional test execution so this is a an API which helps you to enable something to disable something so let's say you want to focus on a part that you want to test so you disable all the parts that you're not interested in or you want to focus on the part that you want to test so you enable some extra features of the parts that you want to test and so on so these kinds of conditional test executions are possible in junit like for example suppose you want to test something on to work only on the Mac operating system or something to work only on Windows or Linux something to work only on a certain kind of architecture um other kinds of processes and so on and so forth you could write several different kinds of conditions this is only for Java runtime environment Java a Java 9 whatever Java 9 to 11 8 to 11 you could do these kinds of stuff you could check for system level properties please don't misunderstand this to be used a system this thing but it's for testing on a particular kind of system not for system level testing so you could do these kind of conditional testing the next thing that I would like to highlight is down below here like we said data driven tests junit can be used to do parameterized test same thing run multiple tests with different arguments and put them all inside your regular test method using this parameterized tests like for example something like this I could say I want to check if a particular string is a palindrome so I pass three inputs simultaneously one input is race car one input is radar and the other input is the string with spaces and you say answer true is it palindrome for this candidate and it will pass these candidates one at a time and then here is the result so it says all three are palindrome so it passed so race car is a palindrome radar is a palindrome and then the string that you see is also a palindrome so you could do a whole set of parameterized tests like this and this section 2.16 down on the left here lets you walk through various ways of doing parameterized tests finally one last bit I am skipping through a few sections hoping that you would read them uh on running tests as I told you this page is updated for junit 5 which works with Jupiter but let's say you use some other ID if you use Intel IJ idea this is how you would run tests there is help available if you use eclipse or jet beans or Visual Studio refer to the corresponding sections help is available for several other Ides also so that was a brief introduction to junit go through these and as and when necessary obviously not all together and familiarize yourself with how are you going to use various features of junit down the down the course to run your test cases okay so now we saw junits features what next as I told you whatever test cases we're going to execute in junit somebody has to design them if you ask yourself where the question where do they come from it comes because test case design has to happen test case design happens because you have a goal in mind you have a test requirement in mind you know what to test and one way of specifying it to say this is your criteria for testing so that's what this course is going to be all about it's going to be all about your criteria for testing so I'll stop here for now and I'll see you all in the next lecture thank you