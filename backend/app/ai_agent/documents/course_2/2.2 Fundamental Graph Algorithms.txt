[Music] welcome back to the second week as i had told last time we are going to use graphs as data structures to start with to learn some test case design algorithms to implement those test case design algorithms you will need some fundamental graph algorithms to work with and this lecture and the next one is about teaching you a few of those elementary graph algorithms most of you might be familiar with it but we'll redo it once again to ensure uniformity as a part of this course so we're going to look at concepts in elementary graph algorithms the first one that we are going to see is depth first search breadth first search sorry followed by depth first search and its applications in testing so in after this i will tell you the kinds of graphs that we will use for testing control flow graphs data flow graphs call graphs and things like that but the goal of this lecture and the next one is to purely learn these graph algorithms from an algorithm design point of view before we look at the algorithms themselves it helps to understand how graphs are represented as far as a program is concerned there are several data structures that you can use to represent graphs the two most simple data structures are matrices and lists graphs can be represented as a matrix called the adjacency matrix or as a list called the adjacency list both undirected director graphs the kind of graphs that we are going to use in testing those that have initial vertices final vertices those that have annotations and edges all of them can be represented using adjacency matrices or adjacency list adjacency list basically talks about for every vertex take the list of all vertices that are adjacent to that vertex adjacency matrix for unweighted graphs is basically a 0 1 matrix that assigns a value 1 if there is an edge connecting two vertices in the graph or it assigns a zero if there is no edge connecting two vertices in the placeholders for the vertices in the matrix adjacency list each list in the adjacency list for every vertex grows or shrinks based on the number of vertices that are adjacent to that so if a graph is sparse that is if it doesn't have too many edges then adjacency list is believed to be a compact representation on the other hand adjacency matrix the size of the matrix the dimension of the matrix is purely dictated by the number of vertices so irrespective of whether the graph is parser dense it is going to be a matrix of dimension n by n where n is the number of vertices so adjacency matrices are considered specifically good if your graph is dense because they have a fixed size so how does an adjacency list representation look like so as i told you take a graph let us say it has some vertices it has some edges an adjacency list is basically an array of lists one for each vertex so let me just shift to the writing board for a minute and tell you how an adjacency list looks like for a small graph so let us take this graph as an example so let me draw a small graph for illustrative purposes so let's say these are the vertices let's label them u v and w so how does the adjacency list for this look like so it's an array of lists so there is going to be a list corresponding to u in this array there is going to be a list corresponding to v there is going to be a list corresponding to w and what is that list going to contain for you what are all the vertices that are adjacent to you so for you vertex v is adjacent to u vertex w is adjacent to u so this is the list that this is going to contain and for b what are all the vertices that are adjacent to b u is adjacent to v it's ah again and w is adjacent to v for w what are all the vertices that are adjacent to w w u is adjacent to w v is adjacent to w w is adjacent to itself so each of these things is a list one list per vertex of adjacent vertices and this is a array so you see the size of the list grows or shrinks based on the number of vertices that are adjacent to it so this is the simplest representation of a graph so let us go back to the slides so this is what it says here in the second bullet for each vertex in the graph adjacency list of that vertex contains all the vertices such that there is an edge from the vertex u to that vertex contains all the edges incident on the vertex view for directed graphs obviously direction does not matter the example that we saw was for undirected graphs so for directed graphs if i take the sum of all the lengths of the adjacency lists then i will get the number of edges because it i put one element into a specific list if there is an edge for undirected graph i count edges in both directions like we did right u was adjacent to v v was adjacent to u so the edge from u to v we counted it in the adjacency list for u we counted it in the adjacency list for v so the sum of the lengths of the adjacency list becomes two mod the adjacency list representation either way requires how much memory how much space it requires theta of v plus e because one ah an array running over vertices and then across all the lists that are mapped to each vertex i count order mod either mod or two mod edges so that's adjacency list how does an adjacency matrix representation look like this is very simple if a graph is n vertices take an n by n matrix and fill it up with 0 or 1 based on whether 2 vertices are adjacent or not so we will again look at a small example so for the same graph let me draw the adjacency matrix so i will just draw it here let me just erase this bit for you so this is the adjacency list that we saw let me now draw the adjacency matrix so how many vertices are there in this graph three vertices so i get a three by three matrix so let me just assign placeholders so there is a place for vertex u there is a place for vertex v there is a place for vertex w there's one more place for vertex u there's one more place for vertex v there's one more place for vertex w now we have to fill in the entries of the matrix so here i have to fill in a zero or one is there an edge from u to u in the graph there is no edge so i fill a 0. is there an edge from u to b yes there is so i fill a 1 is there an edge from u to w yes there is so i write a 1 i go on like this there is an edge from v to u so i fill that corresponding entry with 1 there is no edge from v to v so i fill that corresponding entry with 0 there is an edge from v to w so i fill this entry with 1. w happens to have edges incident on all the vertices so all the rows of w will be filled with one so this is my adjacency matrix is this clear this is how adjacency matrix is looks like so an adjacency matrix is a mod v by mod v matrix there it was a three by three matrix such that the ijth entry corresponding to two pairs of vertices is one if that corresponding edge is there in e otherwise you fill it with zero so if a graph is undirected then if i take the transpose of its matrix i will get back the same matrix because there is no difference its symmetric adjacency matrix obviously needs mod i mean theta of v squared memory so these are three basic graph traversal algorithms that you will use for the purposes of this course very basic algorithms most of you might be familiar with it by now but we will just recap it quickly so that you are not lost looking for other resources to learn about them the two traversal algorithms that we will use are breadth first search and depth first search equal in terms of complexity and enjoy their own properties in addition we might also use algorithms that determine strongly connected components in the graph so we'll start with breadth first search in the this so let us look at the term breadth first search so it is basically an algorithm that searches through the graph in a breadth first way so it goes it starts at some vertex then it looks at the adjacency list of that vertex fully and then goes to the first vertex in the adjacency list that it is populated and goes on from there so it goes breadth first it doesn't go deep down a path instead it goes via adjacency list of a vertex so given a graph g the inputs to your breadth first search algorithm are a graph and a place to start so there is a designated start vertex what does the breadth first search bfs algorithm do it explores or walks through the graph by using its edges and finds vertex one at a time in that process it computes the smallest path that is there between any two pair of vertices in the graph by smallest i mean smallest in terms of the number of edges that you can encounter in that vertex it also can produce a tree that you can use to traverse from one vertex to the other we call that as a breadth first tree and it will contain all the vertices that are reachable from the vertex s so this is the algorithm the algorithm maintains a queue q is a standard data structure it comes with operations of enqueuing which is adding an element to the queue dequeuing which is removing the element from the queue what i'll do is i'll first walk you through an example then i'll come back to this algorithm so let me just go to that example i have it in the slides just for ease of use so on the left here top left you see a graph study the graph a bit how many vertices are there r s t u v w x y eight vertices are there and the vertex named s is the starting vertex is the source vertex from where you start and your goal is to see compute paths for all the vertices that are reachable from s so for example how do i go from s to r there is one edge connecting s to r so that's the path from s to r how do i go from s to let's say u the vertex u right here so i could do s to w w to t or t to u and t to u or another path would be s to w w to x x to y and y to u or i could use s to w w to x x to t t to u so several different ways are there for going from s to u breadth first search explores all these different paths that connect the vertex connects the vertex reachable from the source vertex s and gives you the path that is shortest shortest in terms of the number of edges that you use along the path so how does the algorithm work so we are going to run breadth first search on this graph what is the first thing that we do the first thing that we do is to assign numbers to each vertex as you see here there are eight vertices the source vertex from where breadth first search starts is assigned the number 0 all other vertices are assigned the number infinity this is the first step that breadth first search algorithm does you always start breadth first search from a source assign the number 0 to that source for all other vertices in the graph assign the number infinity alongside that you keep a q data structure let's call that q as capital q to start with you put the source vertex from which you're going to start the breadth first search into that queue so to start with the queue is initialized with the source vertex s so this is the first step of the breadth first search algorithm then what does the algorithm do it starts examining the adjacency list of the source vertex s so if you look at this graph i do not have the adjacency list but i can get it from the graph which are the two vertices that are adjacent to this source vertex s there is an edge from s to r so r is adjacent there is an edge from s to w so w is also adjacent to s so what you do is you take out s from the q and you put all the vertices that are adjacent to s into the q so that is this q in the second step for you so s goes out of the queue w and r which are adjacent to s get into the queue there is no more vertices out of s to be explored so the color that i gave to s which was originally blue now changes to black indicating that i have explored all the outgoing edges from the vertex set s r w and in fact all other vertices were colored white in the first step now r and w are into the queue so they got colored blue w and r are in the queue so you might ask the question between these two vertices w and r which do i put first in the queue which do i put second in the queue the answer it doesn't matter for breadth first search algorithm you can put them in either way now you repeat the same process take the top most vertex in the queue which happens to be w explore its adjacency list let's look at the adjacency list of w w's adjacency list has t it has x throw in them into the queue and get out w from the queue that's the step so w becomes colored black t and x which were new vertex that were added into the queue gets blue r stays on the queue so it stays in the blue now again repeat the same step look at the top of the queue what is there at the top of the queue r is there at the top of the queue look at the adjacency list for r r has two vertices that are adjacent s and v so s has already been explored add v to the end of the queue remove r from the queue color it black move on like that after this which is the next vertex t is the top of the queue explore the adjacency list of t t has what w u and x so w is already been explored u is colored blue x is colored blue gets into the q like this you move on and on and on and on keep coloring vertices from white to blue to black the vertices that are white have not yet been explored by breadth first search algorithm the vertices that are blue you're currently wanting to explore parts out of those vertices by looking at the edges that are adjacent to them the vertices that are colored black are those vertices that are out of the queue and the paths that go out of them or the edges that go out to them have been fully explored no more to explore so this algorithm continues by adding and removing vertices from the queue in a fifo fashion till all the vertices that are reachable from s are explored and q is empty q is empty means what there are no more blue colored vertices all the vertices are colored black this is when the breadth first search algorithm stops in this process it also outputs the tree of shortest paths i'll come back to that in a minute if you see as we've moved along we've double lined some edges there's a blue color there's a black there's a blue line and a black line those are the vertices that get into the tree but for now let me go back to the pseudo code of the algorithm and show you what it is so this is the main bfs algorithm so it says for each vertex u in the graph apart from the source vertex s s is the source vertex set three attributes to that vertex it set its color to white that is u dot color set its distance from the source u dot d to infinity set its pi parent parent for pi in the tree to be nil for s set its color to be blue set its distance from itself to be 0 because it's the same vertex and set its parent's parent to be null because that's going to be the root of the bfs tree the place from where you begin bfs initialize a q to be empty first you nqs into the q n q q s that's what we did now as long as the q is non-empty repeat the following take the vertex at the top of the queue dequeue that vertex right start exploring its adjacency list let us say u is that vertex for each vertex in the adjacency list of u consider each vertex in the adjacency list of u if it is colored white color it blue set its distance from s the d attribute by adding 1 to it set its parent to be u and put it in the end of the queue repeat this process and when you are out of the for loop you have explored the adjacency list of this vertex u fully so you check the color of u to be black and get back into this while loop the while loop basically repeats as long as the queue is non-empty and inside the while loop for the vertex that is there at the top of the queue you explore its adjacency list consider all the edges that were adjacent to that vertex at the top of the queue and if it was colored white that is if you found a previously unvisited vertex color it blue put it under the queue set its distance by increase its distance by 1 set its parent to u and keep moving from there this is basically the algorithm that we saw through this example right so here is a summary of what happens in the queue so bfs maintains a queue of vertices it basically colors each vertex with one of the three colors to start with they are all white along the way they can get blue color and when i'm done with exploring a vertex i color it black right so if a vertex is white it's yet to be discovered by breadth first search algorithm and it's not yet put into the queue when it is discovered but it's not yet colored black it is colored blue and put into the queue eventually when its adjacency list is explored its color will become black and its removed from the queue so this is the queue that we maintained through this example so this is the example that i am trying to illustrate for you i hope this is clear so now some analysis you can ignore this if it is not needed because it is not a course on algorithms we may not need this fully but the basically this slide tells you that the running time of breadth first search is linear linear in the size of the graph which is the count of the number of vertices and the number of edges the other nice thing is bfs also produces the shortest paths so let us understand what is shortest path given a graph g which has vertices and edges and a source vertex s the shortest path distance delta of sv from s to a particular vertex v is basically the path that has as minimum and number of edges as possible these graphs do not have weights in the simplest additions if we have weights then we say it is the least weighted path but in the absence of weights on the edges of graphs we just count the number of edges and say that it's a minimum number of edges so if there is no path from s to v remember bfs algorithm originally initialized the vertex to be infinity so the shortest path stays at infinity indicating that there is no path there are some properties that tell you why bfs returns correctly explores all vertices that are reachable from s and returns the shortest paths i have put them in this slide for the sake of completeness if you would like to learn more about why bfs correctly explores all vertices that are reachable from s and returns the shortest paths you could contact me offline and i'll be able to tell you otherwise these lemmas need basically put together show that bfs works correctly as a procedure for it to work correctly what does it mean that's what this theorem says it says suppose i take a graph and run bfs from a distinct source vertex s then as it is executing bfs finds every vertex that is reachable from s and when it is terminating it will return the shortest path to each vertex from the source if a vertex is not reachable from s then you don't get the shortest paths so if i take the tree of shortest paths it will correspond to the breadth first tree and those edges are what we call tree edges so if you take this example the same example that we had earlier i have now removed the distance matrix that we started out with but the graph is the same s was the source vertex that we started out with and this is how the final output of bfs looks like all vertices are colored black initially all vertices were colored white s was color blue and then subsequently vertices became colored blue and then black i'm omitting all the steps that were shown in the illustration on the right you have this final vertex all the vertices are colored black and the vertices have some numbers associated to them what do they count they count the length of the shortest path so if you see shortest path from s to itself is 0 length of the shortest path the vertex r is reachable from s by just this one edge so the length of the shortest path is 1 then i can go from s to r to v that the length of the shortest path from s to v is 2 that is s to r to v so the that's given here and all the other edges go away if you see for example this edge from t to x didn't correspond to the shortest path so it's not there as a part of the best breadth first tree similarly the edge from u to y is not there as a part of the breadth first tree these double colored edges blue and black are basically the original edges of the graph that are a part of the shortest path tree i keep these attributes as a part of my algorithm i keep a color attribute to help my algorithm work through coloring a vertex putting it into the queue and removing it from the queue which basically indicates whose adjacency list i am exploring then i also keep a d attribute which populates this number to be infinity for all other vertices and 0 for s to start with and then the d gets added and finally becomes this number basically a count of edges from the source that edges that come along the shortest path the so this is the final bfs output you can get the bfs tree of shortest paths you can get how many edges far away is a particular vertex from the source and this in this graph all the vertices happen to be reachable from s so there are no infinite d attribute vertices otherwise it's all the same so that was a short module on bfs in the next lecture you will learn about the other traversal algorithm depth first search i'll stop here for now