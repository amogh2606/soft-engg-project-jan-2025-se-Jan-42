[Music] hello everyone welcome back to week two we saw the basics of graphs then we saw some basic algorithms on graphs now it is time to see how we are going to use graphs in testing so in this lecture and in the next one i am not going to tell you about how graphs are derived from software artifacts but instead we continue to look at graphs as they are and see some coverage criteria that is purely dependent on the structure of a graph so we call them as structural coverage criteria in next week we will see actual code segments how to map them as graphs and how to apply these structural coverage criteria on those code segments so this would still continue to be purely graph theory oriented so as i told you we would like to look at graphs that model software artifacts they could model control flow in methods call graphs in code they could model design elements requirements and then we would apply test requirements on those software artifacts modeled as graphs generate test cases to meet those test requirements test requirements can broadly be of two kinds when we consider them over graphs one is purely based on the structure of the graphs we call that a structural coverage criteria the next would be to augment the nodes and the edges of a graph with information about variables and then consider the flow of the value of the variables we call them as data flow coverage criteria to start with in this lecture and in the next one we will look at structural coverage criteria so when i look at a graph we all know what a graph is what are all the various components structural entities that you find in a graph it has nodes or vertices we use these two terms synonymously it has edges then it could have set of edges set of nodes set of vertices then graphs have paths of various kinds so that's about what we are also going to use when it comes to their use in testing so this slide lists the structural coverage criteria that you will see over graphs so we can cover for nodes and vertices we can cover for edges we can cover pairs of edges and when it comes to paths we could generously say execute all the paths that is complete path coverage we will define a notion called prime paths which are very useful for testing loops in this lecture and then to two entities that relate to round trips and detours i'll tell them about i tell them to you very soon so no nodes in graphs for now don't worry about where the graph comes from what do the nodes in the graph correspond to we will see that next week but assume that you have a graph modeling a software artifact so that graph has nodes and it has edges it has paths so my simplest test requirement could be node coverage what does it say as a test requirement write test cases that will visit every node once in the graph at least once in the graph so cover every node that is write a set of test cases how do test cases for graphs look like they are parts that begin at an initial vertex and end at a final vertex so what is being said in node coverage is that write a set of test cases for a test requirement which is node coverage node coverage says the test cases should visit every node once so that is what is given in the definition here so we say a test set or a set of test paths t satisfies node coverage as a test requirement on a graph if and only if read iff as if and only if for every node that is reachable in the graph syntactically reachable means there is a path from the initial vertex to that node there is some path in this test set t such that that path visits that node so just just let me summarize in simple terms test requirement is node coverage that is write a set of test cases that will visit every node at least once how do the test cases look like they are basically test paths that will visit every node at least once that is node coverage for you the next is edge coverage what is edge coverage say the test requirement for edge coverage as the name indicates visit every edge at least once instead of writing it as visit every edge at least once if you notice the first bullet in this slide we write visit each reachable path of length up to one so what is the length of an edge length of an edge is just the edge right two vertices connecting ah connected by an edge so edge can be thought of as a path of length one instead of saying edge coverage which is visit each edge or visit each path of length one we are saying we visit each path of length up to one right so why do we need up to one that is because for reasons that matter to us in testing we would like edge coverage to always subsume node coverage so suppose i have graph derived from a software artifact and i say my test requirement is to achieve edge coverage in the graph by default for convenience i would also like to assume that it also achieves node coverage that is whenever i satisfy a set of test paths are written to achieve edge coverage the same set of test paths should also achieve node coverage this is purely for convenience and because i need this to be true what i say is edge coverage as a test requirement contains test cases that have to execute each path of length up to 1 parts of length 0 which corresponds to nodes so achieves node coverage paths of length 1 which corresponds to edges so it achieves edge coverage the simple reason is i want edge coverage to subsume node coverage that is as a set of test cases written to visit every edge should also correspond to the set of test cases written to visit every node so that is why i have edge coverage so the next okay so before we move on to the next one this slide has an example so on top here is this small graph very small graph so it has three vertices one two and three as you know by now how to read it ah vertex one is the initial vertex vertex 3 is the final vertex so how many nodes does this graph have 1 2 3 3 nodes how many edges does this graph have edge from 1 to 2 edge from 1 to 3 and edge from 2 to 3. so 3 edges so node coverage test requirement is just basically the set of nodes one two and three test path can be what actually there is a mistake here test path should be one two and then one three it's not just this because there is no path that goes as one two three ah one two three is a path sorry one two two two to three is a path so correct so that covers node coverage so this is correct edge coverage is what is the test requirement is basically the set of all edges as we just said there are three edges one to two two one two three and two to three so the test path that goes as one to two to three will cover the edges one two and two three but then the edge 1 3 will be left out so for that i add this test path 1 3 so for edge coverage the tr or the test requirement is all the set of edges the test paths that achieve this test requirement are these two parts path one two three and path one three is this clear so the next coverage criteria is edge pair coverage so as the name indicates cover pairs of edges so you might be wondering why would i need to cover pairs of edges many times you will realize that when i look at control flow graph of methods and functions the graph will have a such a structure as you see in this slide so there will be several vertices uh edges that converge from several different vertices into one vertex and then there will be edges going out of it so this kind of a structure in the control flow graph makes it very naturally amenable to write a test requirement which says cover pairs of edges because i could do paths of length 2. so i could do 1 4 5 1 4 6 2 4 5 2 4 6 3 4 5 and 3 4 6 as again like just done for node and edge coverage i would like edge pair coverage to subsume both edge coverage and node coverage so i extend paths of length 2 from the test requirement to write paths of length up to 2 right that's mainly because i would like edge pair coverage to subsume edge coverage and node coverage so this example is what we just walked through for this example graph where 1 is the initial node 5 is the final node there are five and six are final nodes there are totally six nodes and five edges the test requirement for edge pair coverage here actually should enumerate all the edges and all the vertices but then subsumption is there so i just write paths of length 2 only so these are all possible parts of length 2. i just read them out to you so the test parts in this example happen to be the same as the test requirements so i hope this is clear now you can go edge pair means paths of length 3 parts of length 4 and so on but then when do we stop if a so i could say cover all the paths consider all the parts in a graph but then take a case where the graph has a loop you know loop means a strongly connected component right so suppose a graph has a loop it means that the underlying code there is a loop in the graph so if i consider all possible parts structurally what will it mean it will mean that i go through the loop once maybe i go through the loop twice i go through the loop three times four times and so on it will become infeasible to cover all possible paths so let me just give you an example uh maybe we will keep here so complete path coverage on graphs with loops so we take an example so let us say this is the initial node you have this this is the final node sorry about the sloppy writing so let's name them as one two three four five six so where is the loop here this is the loop two three four and five this is a loop right so this loop means what there exists infinitely many paths so i could do one to 2 to 3 to 5 to 4 to 2 again to 3 to 5 to 4 to 2. again say let's say 3 to 5 to 6. so here if you see this loop is visited once here 2 3 4 5 2 3 4 5 so like this i can repeat so this behavior can repeat if this repeats then allah it allows many possible paths is it clear so this is why we say complete path coverage for graphs with loops is basically an infeasible criteria i don't know there are infinitely many parts how do i write the test requirement how do i write test cases its not useful at all right so what people do is they say as a tester you specify which are all the paths of interest that matter to you so suppose there was a loop like this you might want to specify and say that cover this loop maybe once cover this loop maybe five times for some reason so people specify path or cover a path in this graph which skips the loop like for example go from one to three to five to six don't go through the loop so people can do what we call specified path coverage where the test requirement is specify a set of paths and then achieve test cases to write those paths and this is completely dictated by the user tester based on their individual needs team needs and so on so this is the thing about complete path coverage and specified path coverage so here i have given another example just to revisit the criteria that we saw so far so on the left you find a graph that has seven vertices one is the initial vertex seven is the final vertex and these are all the paths so there is roughly a decision statement happening at one which lets you take the branch to two or to three there is a loop happening here five six five six five six and then everything ends at seven so what is node coverage test requirement basically the set of all nodes one two three and so on up to seven what would be a test path pick any set of test paths that will visit each node at least once so for example remember all test paths in software testing have to start from an initial vertex and always end at a final vertex remember r i p r criteria that we saw right i should be able to give test cases as inputs and i should let the output be visible always so test paths will always begin at an initial vertex always end at a final vertex so that will be 1 2 3 4 7. that's one test path that visits the nodes 1 2 3 4 and 7 which are the nodes that are left out 5 and 6 are left out so pick another test path for node coverage so you could do 1 three five six five seven so between these two test paths your node coverage is completely met instead you could also do one two three five six five seven that is also fine there there is no requirement about the length of the test path being long or short any test path which begins at an initial node ends at a final node and visits all the nodes will be a good set of test paths that will meet the test requirement of node coverage what is edge coverage test requirement list all the edges so if there is an edge from 1 to 2 edge from 1 to 3 edge from 2 to 3 and so on that is what we have listed here in this place edge coverage this full set what will be a test path any set of test paths that will visit all these nodes so ah what i have listed here that need not be the only set anything else that visits all the edges is fine so i have listed here one two three four seven same as node coverage one three five six five seven edge pair coverage lists all parts of length two it subsumes parts of length 1 which are edges and parts of length 0 which are nodes so i am not repeating them here this list with this dot dot dot here that you see on the right means there are some more to write there was no space in the slide it will become too cluttered so i left it so basically the test requirement for edge pair coverage lists all pairs of edges of length 2 and it includes edge coverage which is parts of length 1 and node coverage which is parts of length 0. so the test paths for edge coverage i have enumerated them here you can check it out write write in your notebook and check it out between these four parts every pair of edges consecutive pair of edges will be covered complete path coverage please note this graph has a loop where is the loop it's from five to six here on on this graph so complete path coverage the test requirement is going to be an infinite set so here also i've put dot dot dot but this dot or dot represents an infinite set so there is going to be infinitely many parts as a test requirement because there are infinitely many parts to achieve complete path coverage is infeasible as a test requirement so we haven't written test paths to satisfy complete path coverage so this is what i explained i will just keep the slide on and quickly revise it so we said that if a graph contains a loop it has infinite number of paths so complete path coverage will be infeasible right so people usually resort to specified path coverage but then you know how good is the tester to specify which is the right set of paths do we need can we have a structural criteria again that will cater to graphs with loops because i i am going to have procedures and functions with loops in my code so the control flow graphs corresponding to them are going to have loops in their structure is there a nice way out that i can typically use to test for loops apart from specified path coverage so that's what we are going to see so typically when you have a loop and when you want to do white box testing for a loop as a tester you will always be worried about can i give a few test cases that will execute the loop once for normal operations let us say a loop is meant to execute 10 times i will give a set of test cases that will go enter the loop and maybe execute it may be five times or six times typically you never give test cases that will execute the loop once twice thrice and so on all possible iterations you won't do that but once around the normal operations of a loop and the other thing that one is always interested as a tester is to execute the loop at boundary conditions that is you skip the loop and see what happens suppose the loop was from i is equal to 0 to i is equal to 10 let us say a while loop or a for loop you pop you give i is equal to 0 and see what happens you give i is equal to 11 and see if the execution skips the loop or not so typically we like to have test cases that cover the loop as it said here covering the loop means what we would typically like to have test cases that execute the loop at its boundary conditions maybe skip also and execute the loop maybe once for normal number of iterations in the literature of testing when it comes to graph based testing there was a lot of open pro i mean this this issue was open how do i efficiently test and then came this proposal through a paper where somebody proposed this notion of what they call a prime path for testing loops so with the rest of the lecture we are going to understand what prime paths are about so to understand the notion of a prime path you have to first understand the notion of a simple path so take a graph take two nodes one ni and one n in j we say a path from node ni to node nj is simple if no node appears more than once except possibly the first and the last node that is a path is simple if it begins at some node if it ends at some node that's okay every path is going to do that and along the way no other node repeats that is it doesn't have no internal loops is this clear that's what we mean by a simple path a prime path is a simple path that does not appear as a proper sub path of any other simple path that is prime paths are maximal simple paths is it clear what a simple path is a simple path is a path where a no internal node appears more than once and a prime path is a maximal simple path that is it's a simple path which doesn't have simple paths inside it so that's what is a prime path so we when we see examples now it will become clear so let us take this graph here that you see above in this slide it has four nodes six five edges and it has a loop so there is a loop one three four one or one two four one it has two loops so let's enumerate all the parts in the graph i have enumerated it in decreasing order of the lengths so it might help to read from this end from this end so these four correspond to all paths of length 0 the single vertices and then i have listed all paths of length 1 the edges of this graph right and then this part contains all paths of length 2 which are the vertices in the graph i mean pairs of edges in the graph and the remaining contains all parts of length 3 this graph has 4 vertices so uh it's not too difficult to figure out that if i need a simple path without vertices repeating then the maximum length the simple path can have is three right because the minute the simple path has length 4 which means what it has 5 vertices and 4 edges but the graph itself has only 4 vertices so one vertex has to repeat then the path will cease to become a simple path so these are all the simple parts of this graph enumerated in order of their decreasing lengths out of these which are prime paths so if you see all simple parts that are maximal in length are prime paths right like for example ah let me take let me take these two simple paths so 1 2 4 and sorry let me take 1 2 4 here and 4 1 2 4 right so 4 1 2 4 and 1 2 4. if you see 1 2 4 as a path is completely contained inside 4 1 2 4 as a path so when it comes to prime paths i let go 1 to 4 because it is not maximal instead i consider 4 1 2 4. so in this case it just so happens that all the prime paths are parts of length 3 which are maximal simple paths but we will soon see other examples where maximal simple paths need not be of maximal lengths so i hope this definition of what a prime path is clear to all of you so i would like to do prime path coverage as the my next test requirement the nice thing is when i do prime path coverage as my next next test requirement i just say take a graph enumerate all the prime paths in the graph we will learn algorithms to enumerate prime paths and that's your test requirement so the nice thing that happens is when i have my test requirement as enumerate and write test paths that will meet all prime paths it magically ensures that if there are loops in the graph each loop is skipped as well as executed so it also happens that prime paths subsume node and edge coverage also because they visit paths of length 0 and paths of length 1. i will skip this slide and come back after the example so we will take the same graph that we had in the earlier slide one of the earlier slides so this graph that you see on the left has seven vertices one is the initial vertex seven is the final vertex it has one loop and we enumerated the prime paths for this graph let me just go back ah i mean we didn't enumerate but we saw this example this is the same example here so the the prime paths for this graph there will be nine of them we will enumerate them when we do a small exercise that will list the prime paths out of these nine prime paths that you will get in this graph it will so happen that these three will be a part of those nine prime paths so one three five seven is one prime path that if you see one three five seven carefully study it by putting it on the graph one three five seven where is the loop in the graph loop is between 5 and 6. so this is a prime path that skips the loop so it corresponds to testing the boundary conditions of the loop the next [Music] prime path is 1 3 5 and 6. so this prime path as a prime path will correspond to entering the loop once when you enter the loop by entering from 5 to 6 i am forced to execute the loop once so that is this prime path 6 5 6 will also be listed as one of the prime paths that corresponds to executing the loop more than once so we will see the same graph and enumerate all the prime parts in detail so prime paths by definition don't have internal loops so they are maximal simple paths so it will so happen like as we saw in this example that when i enumerate all the prime paths for a graph i will end up getting parts that will skip the loop that will execute the loop once by entering the loop and i can reuse paths like this 6 5 6 to execute the loop as many times as i want so this is one part about part about prime path and it ensures that all loops are skipped as well as executed the next thing is by touring all parts of length 0 and 1 prime path coverage subsumes both node and edge coverage the other thing to note is that it may or may not subsume edge pair coverage that is dependent on the structure of the graph so here is an example of why prime paths may not subsume edge pairs so you take this graph on top given here 1 2 3 there is a self loop at node 2. so in graphs where there are self loops edge pair coverage requires the self loop to be visited right for example the test requirement for edge pair coverage for this graph will be what 1 2 3 1 2 and then this edge 2 then 2 and the edge 2 that is this loop 2 2 edge 2 2 and 2 3 and then i should also do 2 2 and 2 that is visit that edge twice right if you see in these this part 2 to 2 the last one is clearly not a prime path right this is not a prime path because the uh there is a repetition of the internal vertices the first three are prime paths sorry the first uh first is the only prime path second is not a prime path third is not a prime path fourth is not a prime path also so there are edge pairs path that corresponds to edge pairs that are not necessarily prime paths and for this specific example so in general i cannot say that if i do prime path coverage i will end up covering all the pairs of edges for this example the test requirement for prime path happens to be this 1 2 3 and then 2 2 which is visit the loop obviously this set for edge pair coverage is not contained in this set for prime path coverage so in general prime path coverage may not subsume edge pair coverage yeah so as i told you there is one more subtle point that we need to know prime paths by definition don't have any loops internally because they are maximal simple paths but sometimes to cover a p a prime path you are forced to visit a loop you are forced to visit a loop and prime paths don't have loops it just so happens that the method for which you are generating the control flow graph happens to have loops and you have enumerated prime parts and these prime paths actually like for example if you see in this example here in the graph below look at this part that has colored this blue dashed uh edges so one to two two two three three two four four to five it happens to be a prime path that skips this loop three six but it's so it might so happen that in the real code for which this corresponds to as a control flow graph it might be impossible to execute this path without without visiting the loop 36 so what we try to do is we introduce two simple notions in testing called touring with side trips and touring with detours what is the tour so we say a test path p towards a sub path q if p q happens to be a sub path of p you can consider two kinds of tours tours with side trips and tours with detours in a tour with side trip what will happen is the edges that come in the sub path q will also come in the sub path p in exactly the same order okay so that is a tour with a side trip i will show you an example very soon in a tour with a detour the vertices or the nodes that come in queue will come in exact in p also in exactly the same or so so that's the difference between side trip and d2 so we'll take this example that we had here under the graph on top graph with six nodes vertex one is the initial one vertex five is the final one my goal is to achieve this path colored in blue and i am allowed to achieve the test requirement of this prime path colored in blue without side trips which will be directly this path one two three four five but for some reason if i am forced to take this loop from three to six i can do a detour with a side trip or a side to side so i can do like this one two three three to six six back to three so i do visit the loop six to three but i call it as a side trip by calling it as a side trip i am basically telling myself that it's not a part of the main prime path it's just a side trip and then i go back three to four four to five or i could even do this one to two two to three three to six six to four four to five in this case i also tour the prime path but with a detour so if you see here the edges in a side trip come in the same order as the edges in the original test requirement the vertices in the detour come in the same order as the vertices in the original requirement that's what this definitions here so a tour a path p towards a sub path q if q is a sub path of p towards with side trips test path p towards sub path q with side trips if every edge of q is also in p in the same order for d tours every node of q is also in p in the same order is it clear yeah as i told this is basically what i have covered actually we saw complete path coverage was infeasible as a test requirement sometimes things can be infeasible and i don't worry if it is infeasible i don't have algorithms to check for infeasibility it's an undecidable problem but i try to achieve feasibility by considering side trips and detours whenever it's possible so when i try to achieve beat infeasibility by considering side trips and detours we call it as the best effort touring that's all that's all this is so what are round trips the prime path that starts and ends at the same node is called a round trip specifically sometimes we might do this and coverage criteria for round trip says you do simple round trip coverage or you do complete round trip coverage simple round trip coverage says at least one round trip for each reachable node should be there complete round trip says all the round trip paths should be covered right so round trips are a separate thing on their own very rarely used in testing i have provided them here for the sake of completeness so in summary these are all the coverage criteria that we saw let me start from this lower end here node coverage most elementary coverage criteria visit each node every exactly once at least once then edge coverage visit each edge at least once edge pair coverage visit paths of length up to 2 at least once prime path coverage very useful for covering loops skip the loop execute the loop once execute the loop more than once we will see in the next lecture how to get algorithms that will enumerate prime paths and in the next week one of the early lectures i will actually tell you how prime paths are useful to test loops and then we have complete path coverage only for theoretical reasons in graphs with loops we saw complete path coverage is infeasible sometimes we will do round trips which are prime paths that begin and end at the same node so you can have complete round trip coverage and simple round-trip coverage so this was a summary of structural graph criteria area and if you would like to know more you can look at the textbook ah that we are going to follow for this part of the course which is this text book by amanda