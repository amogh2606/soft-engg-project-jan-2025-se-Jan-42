[Music] hello dear learners to introduce myself i am meenakshi a faculty member at tripleit bangalore where i have been for the past 12 years i work in the area of software testing and formal verification and teach courses on software testing discrete maths algorithms graph theory and formal verification back in triple i t bangalore i will be teaching you this course on software testing which is paired with the course on software engineering as a part of the online degree program of the bse third year course so to start with i will talk to you about what the course has to offer what will be the learning outcomes and the syllabus of the course and as a part of this video module we will also see a brief motivation to software testing so let us get started so what is this course going to teach you so as i told you ah software testing is paired with software engineering and is a vital part of the entire process of developing software that we all use so in addition the agile methodologies which many companies follow these days put a lot of stress on developers unit testing and integration testing their code so software testing cannot now be considered as a job that will be done only by testers and not by developers everybody has to do software testing of their code themselves so this course will teach you all the aspects of software testing from the process oriented aspects theoretical aspects algorithmic aspects and tool oriented aspects where we will use open source tools to learn how to test your code so in terms of the learning outcomes when you complete this course you will be able to understand which is the right phase of testing that you are in for your piece of code how to phase out your testing into bits and pieces that go in phases apply the concepts taught in the course to design very effective test cases and write your test requirements to be able to design and execute test cases using an open source integrated software development environment and an open source test automation tool and also learn how to extract design models from software artifacts that you can use to design your test cases so what are the contents of the course in the first week like we are in now i will introduce you to the concept of software testing talk about what role testing has to play in the software development life cycle motivate you to software testing what are all the common terminologies terms used in software testing and what are all the process levels that various companies follow for doing software testing and what is a set of good open source tools that you could do to help you automate the testing process that's what we are going to learn in the first week to start with and in the course later a good part of the course is going to focus on test case design where from your software artifact which is predominantly code you will learn how to extract what we call models and then design test cases based on these models one of the first such models that we will be working with are graphs you will learn how to extract graphs from source code from design elements and from specification entities and then we will work with what we call control flow graphs data flow graphs and generate test cases from them this will teach you how to design test cases by using graphs as the basis in this module i will also help you to revise the basic algorithms on graphs and the concepts and graphs that you might need from the point of view of software testing after doing graphs we will move on to logic again i will teach you the fundamentals of logic a revision from what you would have done in a course on discrete maths but this fundamentals will cover whatever you need for the course on software testing you will understand what a notion of a predicate is what a clause is where do these come in artifacts like code in requirements documents how to extract them how to design and execute test cases based on these predicates a very prominent trending technique as far as logical based testing is concerned is that of symbolic execution so this module will also teach you how to test based on symbolic execution techniques after this we will look at a black box testing technique called input space partitioning where we look at the requirements document study the inputs to your software and learn to generate black box test cases based on these inputs and the requirements that dictate these inputs so we take the input space learn partitioning techniques that will partition the input space and generate test cases based on these you will also learn a bit about decision tables and how to generate test cases based on them finally one last design technique generic technique that we will learn is that of syntax based testing or what we call mutation testing we will consider the program as a syntactic entity and learn how to generate low level test cases that can be used to test and debug your program that will avoid and detect common programmer mistakes so after these basics of test case design you will also hand in glove learn to use open source tools mainly a framework called junit which we will use to generate the test cases and automate their execution after this you will learn a bit about integration testing especially testing for design elements and then the course will move on to focused testing techniques for various classes of applications object oriented applications that follow object oriented design aspects are very popular web applications are very popular so we will learn on how to test object oriented applications and how to test web applications what are the testing techniques specific to the testing of such applications agile methodology is a popular software development methodology so we will learn a bit about agile testing and test driven development a part of testing is also devoted to what we call ensuring quality so we call these as non-functional testing or quality focused testing so this course will give you an overview of non-functional testing techniques too the course will also teach you about regression testing which is done post deployment of a software so that is the contents of the course for you in terms of the reference books and material this gives you the predominant set of books that we will follow throughout the course for most of these books you will find soft copies online i will also help you by providing appropriate papers reading materials slides and other information that you might need as we move on in the course so that was an overview of the syllabus and the contents of the course let me continue in this first module by motivating software testing or helping you understand and appreciate why we need software testing as a subject itself so if you pause for a minute and focus and ask yourself the question do i have software in your in my life is software present in our everyday lives the answer is very easy it's a easy yes software is ubiquitous it is very much present in our everyday lives if i have to access my bank i use a piece of software by from my mobile app or from the web browser if i have to make a phone call to somebody or send a message to somebody using my phone or using some other communication if i need access to the internet i need software if i have to buy things online i use software i have alexa at my home which is all the time helping me to make my life better so to say that's another piece of software software in our daily lives exists very much software also exists in homes in building controls in industries in hospitals in cars planes railway networks software exists for us to be entertained social media social networking they're all software toys that children's use also have a lot of software in them so there's no doubt about the fact that software is omnipresent and ubiquitous in our life next if you talk about it you know we want the software to be of very high quality we wanted to work fast keeping pace with our fast paced lives perform well have very good user interface and ideally never fail that is have no errors the other important thing is that we need software to be working continuously up and running all the time the notion of oh is there a problem let's shut it down fix it and then restart it to get it up and running doesn't work for most of the software that we use in our lives so we want systems to be continuously functioning and errors if any should be fixed as the system is up and running before we understand any aspect of testing one good motivation for testing comes by looking at what have been big software errors in the history there have been numerous number of errors that are related to software errors but i will highlight a few of them that are big examples of failures because of software errors one of the early examples in june 1996 was the failure of this rocket called aryan 5 which was developed by european space agency this rocket was launched after 10 plus years of effort millions of euros spent and very unfortunately destroyed itself within 36 seconds after it was launched and the reason why this big fault happened was because there was a software error there was a piece of software which was trying to convert a 64-bit floating point number and write it into a memory space that was meant for a 16-bit integer obviously it didn't have enough memory so it failed these are what we call safety critical software so there's always backup software available but in this case the issue was that the backup software also had exactly the same error so both the original software and the backup software failed incorrect altitude information was passed to the rocket the rocket ended up destroying itself another popular error that you find in history unfortunately resulted in the deaths of a few patients cancer patients receive radiation therapy by these machines that you can see in these pictures one such sample machine is given here and these machines use a lot of software to calculate the amount and the duration of radiation that these patients have to receive as a part of their therapy one such machine gave an overdose of radiation because it calculated an overdose of radiation and that resulted in a few patients losing their lives the reason for this is software error there was a race condition in the software which led to a wrong interleaving of commands of several threads which ended up in the software calculating an overdose of radiation and delivering the same to the patient resulting in depth so these are very unfortunate software errors that have happened another famous error which resulted in a lot of loss to a big firm is this famous intel pentium 4 bug intel is estimated to have lost about 475 million dollars because at that point its p4 bug was doing floating point division in a wrong way such an error was found by a mathematician as a process as a part of his calculations and because of this intel had to recall all the p4 chips that were under circulation in the market and replace them resulting in huge cost to the company and the reason is another software error so by now you get a good idea of how bad software errors can be right we know on one side the software is inevitable in our lives it's present everywhere but an error in this software can be very expensive as these examples illustrate it can be expensive because it can cost lives it can be expensive because it can cause huge fin and financial losses or it can just cause us a lot of irritation by being slow and not working in all the cases errors are unacceptable if you quickly take a break and google you will find many compendiums and lists of software errors available online i encourage you to go through them to understand the impact that these errors have in the working of the software and resulting in an impact in our everyday lives how do we eliminate them how do we systematically find them and ensure that they are not there testing is the only predominantly used and time tested activity to find and eliminate software errors it's estimated by the software industry stalwarts that more than 50 percent of the total industries efforts is spent on testing and quality assurance so now that we have seen errors and we have seen the testing can solve them let us spend a few minutes trying to understand the kinds of software that we work in our everyday lives so the parts that are highlighted in blue in this slide are one classification not exhaustive of the kinds of software that you will see the first kind which is the kind of software that i do research on especially when it comes to testing is what we call embedded software the software that you would find operating the power window in your car operating the parking assistant in your car operating the gps in your car or may be operating a rail network the software that helps with autopilot or landing in an aircraft a software that operates our lifts they are embedded as a part of a system that is tightly coupled to the hardware and almost always safety critical if there is a problem in this software it will immediately result in accidents so we want them to be error free other kind of software is what we call enterprise software software that runs in the banking and financial sectors software that operates at the back end of all these e-commerce companies and so on they operate with large databases they have critical server requirements several clients accessing them online they all have to be correct they cannot fail the next kind of software is web application software that runs through our browsers that we use they also have to be correct they have to be available to several different users who are not necessarily proficient software developers because they are meant to be available for the public to use for the public to consume several different languages and they have different kinds of correctness requirements different kinds of errors that come in them another popular category of software is the mobile applications that again most of us are dependent on they also cater to common man and have to be available almost everywhere and errors in these can be expensive ironically we also use a lot of free software for which we don't pay for and we expect all that free software to you that we use to also be free of errors right so the kind of errors that come in each of these kinds of software are very different and the kind of techniques that we might need can also be different to find and to fix these kinds of errors so the next important thing that motivates why we need to test early and why is testing important is software typically is developed using a well-defined process is what we call a life cycle i'll tell you in the next module what a software development life cycle is you will learn more about it in the software engineering course so initially you write what we call requirements then you do what we call design then you write coding and then you do testing and deploy software suppose you find an error early on that is when you are writing the requirements or design of your software then the cost of fixing that error is cheaper that's what this graph says look at the red bars that it depicts the cost in this picture suppose you find them at the level of unit testing that is while coding or at the level of integration testing while putting together your code then also it's not too expensive to fix these errors suppose you find them later specifically after you deploy the software look at how tall this red bar goes the cost of finding an error and fixing it gets very expensive the kind of errors that i told you earlier be it in the rocket or be it in the radiation machine or be it in the intel pentium chips they were all errors found post-deployment and hence very expensive when they actually come in terms of finding them and the cost that it has in terms of loss of lives or loss of finance is very expensive so the earlier that we find errors preferably the better it is for us so it's important to test early as you're writing your code so testing i will walk through the software development life cycle i will tell you what sdlc is briefly in the next module and it occupies a large part of the software development life cycle these days most companies follow agile development methodologies and agile methodologies insist that developers unit test their code themselves you cannot say i've written this cool code i think it's working fine here you test take my code test it and let me know where there are errors that doesn't work that way in agile as a developer the onus is on you to unit test your code also so testing is should be an integral part of every phase of sdlc and agile methodologies which are being followed these days do make this a reality the other truth that you should know is many errors are basic coding errors which are mistakes made by programmers and they are best found then and there as a programmer or a developer unit tests his or her code it's best to find errors right there and fix them it's best if they do not move on to later stages of the software development life cycle so i would also like to use this motivation module to tell you what are the popular facts and what are the popular myths about software testing let's start with the facts the facts is testing is a well known technique to find errors in software every error that testing finds is a real error can be fixed but using testing is wrong to say that my software is fully correct that i have tested my software well and my code is fully correct testing cannot be used to make such a statement testing can only be used to find errors and fix them at no point in time will testing give you the confidence that your software is fully correct right i hope you understand the difference between these two terms the other thing is that testing also has to be done alongside other quality review processes which are reviews done by quality inspection team reviews done by a dedicated software quality auditor and so on these two together are very effective in finding all the errors later in the course we will do one module on this quality what is inspection and things like that the third important fact that you need to know about testing is that testing is heavily automated there are lots of tools that will help you with testing but it cannot be fully automated you need a human being you need to know the domain of the software and you need to know certain aspects of software testing to be able to design effective test cases which will be effective in terms of finding bugs the execution part can be automated test case design needs algorithmic knowledge needs human intervention so that was a summary i hope i motivated software testing enough for you remember that it's an inevitable activity of software development and agile methodologies put a lot of stress on testing if you are going to take up a job as a software developer you are going to be in a company that is agile in some way so you will have to do testing a lot and testing is as old as software is i'll tell you why we'll take some examples from real historic code and talk about errors that people found in that code so the goal of this course is to teach you all the software testing that you need to know as a developer welcome to this course