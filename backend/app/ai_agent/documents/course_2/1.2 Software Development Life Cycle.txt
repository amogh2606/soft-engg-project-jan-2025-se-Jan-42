[Music] welcome back this is the second lecture of week one before we move on to learning about software testing it's important to get an idea of the entire software development life cycle testing is only a part of it the paired course on software engineering will teach you a lot more about the software development life cycle but for completeness sake i thought i would start giving a brief introduction on software development life cycle with a little bit of focus on where testing might come into picture so this module is on a brief introduction to the software development lifecycle for you so let's understand what software development lifecycle is about so software development lifecycle abbreviated as sdlc is a broad umbrella term used by the software industry to define a process a way by which they would design a piece of software decide on what to build a software for develop it test it and release it to the market or give it back to the customer who ordered the development of software for them so it's a set of process or it's a way that tells you how a team in a company would go about creating a software end-to-end it's synonymous with the term software development process and abbreviated as sdlc the goal of an sdlc is to define processes or ways by which one would strive to develop a high quality software that will meet all the expectations from the customer in fact not only beat but exceed all the expectations from the customer like in all other industry software development lifecycle also has an iso standard and the iso iec standard 10207 is an international standard that defines software lifecycle processes feel free to go through it a bit to the extent that you can get on open sources you will get to know what the standards are and how they define these software development processes many companies especially the large scale companies tend to follow these kinds of standards to be able to define the software development lifecycle processes within their organizations these standards help them to do that so let's understand what the activities that are there in a software development life cycle are to start with right in the beginning you do what is called planning you need to know what are you going to write a software for what are your development goals what are the requirements that the software should satisfy who is going to give me the requirements who is going to check whether the software will meet the requirements how much time do i have to finish developing this software and release it how many people do i have how do i delegate tasks so many different questions to be asked and answered in the planning phase after this you also collect requirements which is an integral part of the planning phase that is what is your software meant to do once you collect requirements you move into what we call designing an architecting software which comes up with the skeletal framework of how you're going to develop your software post twitch you typically do coding which is the implementation phase along with that do testing which is to test if it meets all the requirements and if it's otherwise error free and after release your job doesn't stop there you can't sit back and say i'm done with this cool software that i've written handed it over to the customer i'm done maybe there will be errors that software will have post release maybe the customer will ask for new feature enhancements so most of the software go through what we call a maintenance phase which comes post deployment so these things are put in a circular fashion overlapping with each other because they are heavily dependent on each other in terms of various sdlc activities so how do i know which one follows the other how do i fix the order which would be the right kind of activity to do when those are the kinds of things that the various models teach you will first understand little by little what each phase does typically the first phase in the software development life lifecycle is always the planning and the requirements definition phase as i just told you planning includes clearly identifying what the requirements from the customer are what are the requirements that will identify me and distinguish me from what is already offered in the market what are the market needs pursue a feasibility study find out how much time you have and come up with an initial set of requirements you take that initial set of requirements elaborate it to a larger set of requirements of various different kinds typically the output of this would be at least half a dozen requirements documents so you will have what we call a system level requirement functional requirements software requirement you also call them a software requirement specification srs document for short you will learn about these in the other course hardware requirements requirements for quality performance latency reliability maintainability user interface they all get approved by the appropriate stakeholders you create lots and lots of requirements at this stage typically can take several weeks or even months to do this not only create requirements you also begin to analyze the requirement is my requirement feasible am i asking for something that is impossible to develop impossible to design you ask yourself that question try to arrive at an answer is a requirement correct do two three requirements contradict with each other does one requirement imply that the other requirement is impossible to achieve is there a cascading down dependency that is natural between the requirements so you also go through what we call a requirements analysis where you check for all these properties is my requirement consistent have i left out anything important without specifying it does one requirement contradict the other is there a natural flow between the requirements you analyze these kinds of things at this stage so typically a work product here would be requirements documents of various kinds as i told you one for software one for system level one for hardware one for functional one for non-functional so on the list can be really long you also come up with what we call the project plan which typically identifies the duration that this entire development effort is going to take by when will the product be ready do i give intermediate releases how many people do i need for how long are they going to work that's what the project plan is going to talk to you about if you take an example and we sort of walk through that example down the sdlc let us take something that we all use let us say i i have i use swiggy to order food for my family once in a while swiggy what would be typical requirement for a software like swiggy basic system level requirement must be that it should be available as an app on my phone it should be available on the web browser also for somebody who is not familiar with the phone maybe it should be available in different languages it should correctly tell me which restaurants give what kind of food it should have a good estimate on the time that it takes for the restaurant to be able to deliver sitting here can i order for let's say my friend or my relative in another city you know these are all what we call requirements some of them can be exclusively about software some of them can be about user interfaces some of them can be about the system level requirements you basically collect categorize create these documents and plan at this stage after this comes the second phase where you design and also define the architectural elements of your software what is the difference between design and architecture hopefully the other course will tell you but broadly speaking design identifies all the modules of the software product details out the internals of the module tells you that this is the high level design let us say you use object oriented design concepts these are going to be my classes this is the class inheritance hierarchy these are the methods some of these methods are polymorphic these are the constructors so this is how you talk about design diagram typically written maybe as a set of class diagrams that talk about inheritance may be written as uml models whatever you want to call it as so design talks about all the modules of the software product tells you what the internals of each module is going to look like the low level design almost talks about the code and also gives you a skeleton to generate what we call integration tests later along with design comes architecture which talks about the modules how they are connected like for example suppose i take this wiki app i want it to be available on a phone that has android i want it to be available on iphone also i also want it to be available from let's say the edge browser from chrome browser or from firefox browser this is what the architecture is going to focus on what does it mean various operating systems that it's going to run on various databases that it's going to access the browsers that it's going to run on and other user interface aspects of it is what the architecture is going to talk about typically design and architecture always go together they are hand in glove with each other we also validate the design and architecture suppose my architecture demands that i need the coolest of the operating systems which is yet under production then it's not a feasible architecture right i need to be able to cater to the currently available products in the market on which i can architect my product on so we do feasibility study we also do what we call system level test cases from these documents so the typical work products are documents that have designed an architecture they could be static documents like pdf file or some other documents that you create in an editor or they could actually be models like you could create design and architecture models in dedicated languages modeling languages that are present for them uml sysml aadl any of these could have these kinds of models the next phase after design and architecture is the coding or the development phase design documents typically contain what we call a low level design that are used to write your code and if a design document is well done modeling is well done code generation is fairly smooth process there are coding guidelines that the organization that you will work for will tell you and you have to follow those guidelines when you write code along with coding agile methodologies especially insist on the developer doing debugging of the code along with unit testing himself or herself so unit testing which is testing at the level of a method testing at the level of a procedure or a function is done by the developer alongside coding and in this development phase a lot of the tracking is done by team leads and the project managers work products are fantastic documents here they are the actual executable code along with documentation and the test cases that you have used to unit test your code after this comes testing obviously there was testing here itself in the development phase which is unit testing of the code done by the developer the next phase is again testing but this testing is slightly different from the unit testing so this phase involves not writing any more code but focusing only on testing where the product is thoroughly tested defects are reported fixed and retested until all the functionality is satisfied typically people do what we call integration testing at this phase where if two three modules are developed then they are put together or a software module is put together along with the database and the hardware and tested directly on the server so you could do software integration testing or system integration testing at this phase and it is carries forward from all the earlier phases involved little bit of testing and validation this phase focuses only on testing and validation along with this wherever it is needed if your particular software has to be certified by a third party or accredited by a third party the kind of documentation and the testing that you would do for that is also done at this phase typical work products are test cases and test documentation post this comes maintenance you've finished developing a software tested it thoroughly system tested it released it to the customer there could be new errors that are found at that point in time or a customer could ask for feature enhancement of these errors so maintenance goes for longer sometimes several years till the lifetime of the software post deployment where typically any errors that are found are fixed and the software is retested any new features or change requests that the customer wants are also added and in this phase test cases that you've created in all the earlier phases during development are reused partly and new test cases are created so there is a whole sub area in testing dedicated to this phase and that is called regression testing we will see regression testing in detail later so that was about what each phase of the software development life cycle was historically if you pick up any theoretical book on software testing you would have learnt about these software development life cycle models waterfall model v v model spiral model rad model incremental model big bang model you know you can google for these terms plenty of information on the internet and on software engineering textbook is available for these models i am not going to walk you through all these models but we will focus a few that is relevant for the purposes of moving on in this course so v model for software development is a model that extensively focuses on testing so it's a model that focuses on verification and validation they are terms related to testing they will be clarified in the next lecture it follows the traditional sdlc life cycle it is a lot like the water model you first do the planning phase write your requirements then work on design and architecture then do coding and unit testing then do integration testing deploy a software and finally do maintenance related activities so that flow is the same as the traditional waterfall model waterfall model i didn't tell you about but it's this just this what is different between the v model and waterfall model is for each of these phases v model does a direct mapping to the corresponding testing phase this figure that i took from tutorials point dot com which i extensively use is a pretty good website will tell you what v model is all about so if you look at this top left here there is requirements analysis the planning phase followed by system design which we saw followed by architecture which we again discussed then low level design coding so this is the left side of the v i hope you can see the v here and on the right side along with coding you have unit testing then integration testing where modules are put together system testing and finally after deployment or just before deployment you do something called acceptance testing and what are these arrows that go across these layers what is basically saying is the test cases for unit testing will come from the module design the test cases for integration testing will come from architecture the test cases for system testing will come from the design documents the test cases that you use during the acceptance testing phase are likely to come from the requirements document so this v model focuses a lot on testing that is why and it also fixes the dependencies on where the test cases will come from which faces another popular development model which is practically ubiquitous these days is an agile software development methodology it's not one particular model but it's a collection of methodologies you will learn a lot about them in the other course and again in the firm that you will be working on currently it's the most widely used sdlc model agile as the word says means agility be adaptive customer needs are changing market needs are changing so be adaptive to it don't wait for the entire requirements to be written out for the entire design to be done for the entire implementation to be done then do the testing and maintenance do it in small subsets is what we call features that are incremental in nature release your software with first set of features do everything across the sdlc in terms of faces for that release add a new set of features as an increment do everything again release the new set of features so that's what agility caters to how do you know which is the first set of features which is to be added at every stage so agile models are extensively dependent on customer interactions quick delivery rapid response and rapid development so this is another picture that i got from tutorials point which actually tells you nicely how agile models for software development work in a generic way if you see this blob here there is iteration 1 iteration 2 iteration 3 and so on and each iteration all the faces of the sdlc are encountered in the first iteration i plan do requirements analysis design an architecture write code test releases release a set of features of my software maybe the first version second iteration i repeat the whole thing again plan write requirements for this iteration add design and architecture for this iteration add code for this iteration test release again iteration three and so on not exactly three iterations all the time this is just meant for illustration but i hope you get the essence of what it is you essentially are agile adaptive and your software is developed in quick phases what we call sprints in an incremental fashion along with these models i have discussed a few popular ones there are a whole set of other ones big bang rapid application development incremental and the good old waterfall model which i haven't talked to you about in detail along with these there are a whole set of other umbrella activities that are performed as a part of the software development initiative we discussed about project management which is initiated in the planning and requirement phase so you manage a set of teams you know how many teams are there who's going to report what who is developing what how do i put together all this code how long is it going to take what is the billing rate you know lots and lots of project management activities happen and it's a very important part of the software development life cycle another important part of the software development life cycle is documentation the the artifacts that you create as you write code code is of course the most useful artifact followed by test cases which you are going to validate your code with but along with that you also create several other documents one important such document is what we call the requirements traceability matrix rtn you can look for it what it means is so we talked about the various phases of software development planning requirements design and architecture coding testing how do you know what is how these faces are related what i plan for which part of the design caters to which requirement which part of the code caters to which part of the design which in turn caters to which part of the requirement how do i trace these things so that at the end of it i can say see my code put together as a piece of software meets all these requirements and maybe does not meet a few of them how do i achieve that i keep track of what i call a traceability matrix which is a document could be even be an excel sheet that links each of the artifacts that are developed work products that are developed as we go through the software development life cycle this requirements traceability matrix or document is the key document for making testing especially in the latter stages a very effective way to find and fix the errors along with these as i told you there are software quality auditors quality inspection teams certification teams accreditation teams that you work with who will certify a software and say it is ready to go to the market it's safe and it has been well tested so that also is an integral part of the software development life cycle and software development activity i mentioned this in the passing as a summary slide because we will not be looking at all of these except maybe for one set on quality inspection but remember that these are very important part of a software engineering team alongside software development activities and they are as integral as software development itself to make sure that the software is successful so the goal of this module was to give you an overview of sdlc what are the faces of sdlc and introduce you to some of the models in the next module i will introduce you to the testing terminologies that we will be using throughout the course thank you