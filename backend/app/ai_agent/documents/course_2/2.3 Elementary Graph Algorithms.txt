foreign [Music] welcome back to week two we're going to continue with Elementary graph algorithms in the last lecture we saw breadth first search now I am going to talk to you about depth first search the next most popular craft reversal algorithm and one application of it which helps us to find strongly connected components in graphs so unlike breadth first search depth first search goes deep down a graph starts from a source vertex takes one of the vertices that is adjacent to the source then looks at another vertex that is adjacent to the child of the source vertex and goes down and down and down when there are no more vertices to explore along a path down from the vertex s therefore such comes back and looks at other vertices in the adjacency list so it explores a graph in a depth first way unlike breadth for such which explores the graph in a breath first with so as I told you DFS explores edges out of the most recently discovered vertex B that still has unexplored edges leaving it once all of these edges have been explored the search backtracks to explore edges leaving the vertex from which we was found this process continues until all the vertices that are reachable from the original Source vertex that we started out with they've all been added as reachable vertices they've all been found or discovered and if there are undiscovered vertices that stay back DFS starts all over again from a new source and repeats the search this process goes on till every vertex is found and like breadth first search you can prove a theorem which shows that depth first search discovers every vertex that is reachable from source and if you reset the source it will discover new vertices that are reachable from source it doesn't give you shortest paths like breadth first search but it gives you a whole lot of other useful properties of exploring vertices in the graph so depth first search returns a forest of depth forest trees by looking at the pi attribute like we did in BFS you can populate the trees and the edges that double colored edges that we saw like in breadth first search will be called as tree edges so same like in BFS we color the vertices there we colored it white blue and black so here also it to start with its white then it can get an intermediate color let's say gray color or a blue color and when it's finished it gets a black color so when it's not yet discovered it's white to start with all vertices are white when it's discovered for the first time it gets colored gray or blue and when it's finished it gets colored black along with color we also assign timestamps in breadth first search we assigned a discovery timestamp which measured the distance in terms of the number of edges here we also assign a finished timestamp that is we assign a discovery Times tab to indicate the Step at which the vertex was colored from white to either gray or blue that is when the vertex was discovered and then we assign a finished timestamp when we are finished with exploring that vertex fully that is when that vertex finally gets colored black obviously a Vertex should first be discovered before it is finished so for always it is the case that the discovery timestamp is strictly less than the finished timestamp and totally these timestamps can never be more than the number of edges and it's never more than twice mod V so to start with before it's discovered as I told you a Vertex is gray I mean it's white sorry when it is discovered it's assigned gray or blue color when it's finished it gets assigned black color so again what I'll do is I'll walk you through the algorithm the slide I put it as one image but uh I will illustrate a few steps of the algorithm on this graph and then we can understand the pseudocode so let me keep the white board adjacent to this so that we can copy down the graph and then see what it is so the graph that you see here at this point right that's your Source graph so how many vertices does it have it has six vertices so let's copy down the graph here so that's one vertex that's one vertex third fourth fifth and sixth vertices so they are labeled u v w x y z as you notice it's a directed graph so edges have directions in them by the way both breadth first and depth first search will work for directed and undirected graph it doesn't matter it's the same algorithm I hope you are all clear about that so let me just copy the graph for you from the slide onto this white board so that's it this is the graph so now we have it so let's move the white board to the center before we go back to the slides and illustrate a few steps of the depth first search right I'll keep this little bit of the slide popped up on top so that you can see what is happening right so let's say this is my starting vertex this U is my starting vertex so I begin my depth first search from here this is my vertex so this is my start vertex so I assign a discovery timestamp discoveries timestamp is one that's what is put inside the label of the vertex so I have discovered it so I am going to put one because there's not enough space I'll write it outside now I look at how many vertices are adjacent to the vertex U there's an edge from U to B there's an H from U to X I can pick up any of them it doesn't matter let's say I pick up V so what I do is I take this graph and the next word Edge that I choose is this Edge is this Edge so I'm going to double color this Edge and this is the next vertex I pick so I'm going to assign timestamp Discovery timestamp 2 to this now I start looking at the adjacency list of V there's only one vertex going one Edge going from V to Y I don't have much choice so I pick up that edge put it onto my tree and assign Discovery times Tab 3 to 1. now I look at the adjacency list of Y there's only one that goes out of Y so I assign timestamp Discovery timestamp 4 to Y and then I put it in my dfst now I look at the edges going out of X there's one Edge going out of X into the vertex V which has already been discovered because I have assigned a discovery timestamp strictly speaking I should also color but because I am managing with the same graph I'm not coloring so this I don't consider right so if I don't consider then what do I do at this point basically I have reached a point where I have reached a Vertex from where there are no outgoing edges to new vertices right so what does it mean that means I am done with exploring that vertex so I say I'm done with exploring X so I assign a finish times time to X which is 5. and say this Edge that I found here this Edge is a cross is a backward Edge I'll tell you what a backward it is but let me color this B okay sorry for the very colorful example but it helps us to understand so now I go back I came to X from y so I go back I now look at the same thing do the same thing look at the adjacency list of Y anything left no X is there I finished exploring X nothing left in y so I say I finished exploring y also so I assign finish timestamp to this so by the way I can now color X and Y both as black I'm not illustrating here so I go back like that now go back to V anything to be explored out of V nothing so I assign a finish timestamp to B and I move on like that so let's lower this white board for now go back to the slide and see what where we were so DFS goes on running like this we were here and at this stage we assigned a finished timestamp to X where my mouse is this is the copy of the graph which is marked F here after that I'm also done with exploring y so Y is colored black I assign finish timestamp to y That's this graph marked in G then I go back I go back to V I've explored finish exploring v v gets colored black gets assigned a finish timestamp at this point I go back to you here the graph down below here and I look for are there any more edges yes there is one Edge which is goes from U Down To X but X is already been colored black so it's not a new vertex that I'm finding so I say this kind of edge is what we call a forward Edge in DFS because it is an edge that connects the vertex that I had started out with originally to an already finished vertex so this is an edge as an edge it calls it's called a forward Edge so I say oh I basically found a forward Edge there's no more new edges to be explored from you so I color U black and assign a timestamp so I am done with these four vertices now I come to this side this graph actually has two more unexplored vertices that has that are white in color I can start all over again I can consider one of them as the source let's say I consider W as the source so I assign a discovery timestamp for w the next left number I've used up till 8 so now I say Discovery timestamp is 9 then I'd repeat the same thing I go from W to Z finish exploring Z Color Z black discover finish Z come back and finish W that's the easy way of doing depth first search so I am basically exploring adjacency lists but I'm exploring them in a depth first way I go down and down and down and down picking up one one vertex success of vertex in the adjacency list instead of going in a breadth first way where I pick up subsequent successor vertices now we are ready to look at the pseudo code of DFS so the procedure is called DFS of G it takes a graph G and first what does it do for every vertex in the graph it assigns it colors that vertex White it assigns its parent to be nil and says now I need timestamp so it keeps a variable called time to keep track of timestamps initially it says time is 0. now what it says if now you take any white colored vertex as your Source let's say that vertex is U and start this routine called DFS visit from that Source let's look at what this procedure DFS visit is so DFS visit is going to do DFS on the graph G with u as the source vertex the first thing that it does is increments the timestamp variable to by 1 and says for the vertex U assign its D Discovery time to be that value of the timestamp and color U gray that is lines 2 and 3 for you start exploring the adjacency list of you exactly like we did in breadth first search for each vertex in the adjacency list of U if you find find that its color is white set its parent Pi attribute to U which is used for computing that tree and this style of writing this is slightly different from the style of writing breadth first search pseudocode that we saw in the last lecture here it recursively calls DFS visit again from V so what will it do it'll start exploring in the next Call of DFS visit it will start exploring the adjacency list of v and if it finds a white colored vertex it'll make v as its parents and call DFS visit from that vertex once again when this for Loop ends it'll come and say I have finished exploring the adjacency list of U completely so you color you black which means I'm done with exploring you increment your timestamp value and say that is the finished time of the vertex U so line 9 increments the timestamp value and line 10 assigns it as the finish time of U I hope this algorithm is clear this is basically what we saw in this example so like BFS DFS also takes linear time why because there's a initialization Loop and after that the for Loop runs once for every vertex as long as they are just there are vertices in the adjacency list and the vertex one color of the vertices progressively go from Blue uh White to gray to Black they can never get recolored so at most it's moddy so the running time of DFS is linear in the size of the graph which is mod V plus model again now we have a few theorems that talk about why DFS is correct what are its properties and all that I have kept them in the slides for the sake of completeness but I'm not going to go through the details of all these theorems basically the first theorem which we call the parenthesis theorem says that what we saw earlier right a Vertex is first discovered and then it is finished so the discovery time is always less than the finish time and if I Mark the discovery and finish times properly then they look like pairs of nested parenthesis so if I take the interval between when a Vertex U was discovered and when a Vertex U was finished and if I take the interval between when a Vertex V was discovered and when the word vertex V was finished if the two intervals are disjoint then U is not a descendant of V and V is not a descent interview they cannot be reached from each other whereas if the two intervals are such that the interval for you is completely contained within the interval for V let's say U was discovered at time stamp 3 finished at timestamp 6 and V was discovered at timestamp 1 and finished at timestamp 8. so interval 2 6 is within the interval 1 8 then it means that U is a descendant of v in the depth first search a tree and the third bullet is the reverse of that so you can check it out for this example and for proofs refer to any standard textbook on algorithms one of the need reasons needed for correctness of this thing DFS then there's a white path theorem which says that when I first look at a Vertex V if I start a DFS from a Vertex view when I first look at vertex V I basically have a path of white colored vertices from the vertex uh to the vertex V then this is one thing that I briefly told you about the vertices that get into the tree are the vertices that you use for traversal those are the three edges uh sorry the edges that get into the tree are the edges that you use for traversal those are the three edges if I find a forward Edge that is if I end up reaching a Vertex that is already colored black through another adjacency list exploration then that edge becomes a forward Edge package are those that connect an ancestor back to a I mean a descendant back to an ancestor and if it doesn't belong to one of these three categories then we say that the edge is a cross Edge yeah so if the graph is undirected our example the graph was directed but if the graph is undirected then I don't get forward edges and cross edges I only get three edges and packages yeah so that was depth first search it was a quick module uh feel free to ask me questions when you're revising this or refer to any standard book on algorithms if you would like to know more about DFS but from the point of view of testing you could just pick up use in testing you could just pick up any routine that implements DFS for our purposes later in the course one more algorithm that will be useful for you that's related to graphs which we will need for the purpose of this course is to understand what a strongly connected component is so let me go back to the Whiteboard and draw an example for you so I'll keep this aside and illustrate strongly connected components so we'll take an example of a graph so let me just draw a graph please excuse my not so great handwriting strongly connected components are defined for directed graphs if a graph is undirected then you call it a connected object okay let's label these vertices u v w x y z so this is some graph G so what is a strongly connected component in G let's go back and look at the definition then we'll come back and see it in this example a strongly connected component of G is a maximal set of vertices such that every pair of vertices they are reachable from each other so remember this definition let's go back and see how strongly connected component is a maximal set of vertices why maximal the largest set possible I'll illustrate it on that example such that within that set C every pair of vertex is reachable from each other so let's go back and see so let's take this strongly connected component and let's start with the vertex U so I claim now let me Mark I claim that this part defines one strongly connected component so C1 first strongly connected components consists of vertices u v x and y if you see U is reachable when V is reachable from U there's this Edge U is also reachable from e v you go to V to y y to x x to U similarly U is reachable from X through this h x is also reachable from U right you uh you can go U to v y v to y y to X so all these four vertices are reachable from each other now why I didn't put W as a part of this block if you see V is reachable from I mean w is reachable from v through this Edge but this uh U reachable is uh U reachable from W answer is no try you can go from W to where the only vertex you can go out of w is W to Z and then you can come back to W there's no way I can reach U or V or X or Y from W so w doesn't belong to this strongly connected component for the same reason Z also doesn't belong to the strongly connected component in fact this is the next strongly connected component this one because between w and z they are reachable from each other so C2 is w and z so strongly connected component is a maximal set of vertices like for example u v and uh sorry e v x and y is also a strongly connected component of size 3 it has three vertices but I can find the larger strongly connected component of size 4. so it's maximal because it's as large as possible so it's a maximal set of vertices such that every pair of vertices within that set are reachable from each other so the nice thing is you can run depth first search as a subroutine to illustrate all the strongly connected to pull out all the strongly connected components of a graph so the algorithm that uses depth first search to generate strongly connected components in a graph uses the notion of a transpose of a graph so let's see what that is transpose of a graph G is basically you retain the same set of vertices keep the graph v as the same set for edges if I had an edge in the direction from V to U okay change the direction of the edge take a graph keep all the vertices as they are for every Edge change its direction then you get the transpose of the graph if you see this takes a bit of thought if you see the original graph and its transpose will have the same set of strongly connected components because the same things will be reachable from each other strongly connected components means what reachability both ways it's like a that's why it's called strongly connected it's reachable from both ways transpose I'm not changing anything except for the orientation of edge so graph and its transpose will have the same strongly connected components because reachability both ways will be preserved so this is the algorithm for strongly connected components so you first take the graph run DFS on the graph DFS outputs what tree of DFS a depth for search tree it outputs the start Discovery Time finish time so what step one says is run DFS remember finish times the F attributes for each vertex then take this graph compute G transpose just take the adjacency Matrix of the graph take the transpose of the Matrix that will give you the transpose of this graph flip the direction of each Edge now you run DFS once again on the transpose of this graph okay now don't choose vertices in any arbitrary order but in the main Loop of the fs let's just go back to the DFS code for a minute I'll go to that slide so this is the main Loop of DFS this one here you say no each vertex in the adjacency list which vertex you choose if there are more than one it's up to you it doesn't matter based on which one you choose you might get slightly different DFS tree but in this to compute strongly connected components what do we do second time when we call DFS on the transpose of a graph in that main Loop that I just showed you you don't consider arbitrary order but you consider vertices in the order of decreasing finish times finish times as computed in line one okay now you'll get DFS trees for line number three it so happens that each such DFS tree will be a separate strongly connected common that's what it is so again a few lemmas that will tell you why this is correct but I'm skipping through them because uh this will increase the length of the recording lecture but again feel free to refer to any standard book on algorithms or get back in touch with me if you would like to understand the correctness of this algorithm but remember this is the critical part BFS and DFS are two graph traversal algorithms BFS enjoys the property of giving you shortest paths DFS gives you Discovery and finish times uh DFS can also be used to compute strongly connected components which are like maximally connected Loops in the graph so in the next module what we are going to do is directly start looking at some coverage criteria on graphs and I'll tell you how later on we are going to use these algorithms to generate test cases from graphs that we are going to consider for test I'll stop here for now thank you